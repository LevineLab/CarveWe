---
title: "Experimental SOM clustering based on an 80% quality threshold"
output: html_document
date: "2023-08-04"
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../Output",
      output_file= "CarveMe_double-scaling_hq.html"
    )
  })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.height=12, fig.width=12)
knitr::opts_knit$set(root.dir="/Users/Ryan/Documents/Levine_Lab/R_Studio/CarveWe")
#Load in packages
library(SOMbrero)
library(gplots)
library(tidyverse)
library(patchwork)
library(purrr)
library(ragg)
library(ggtree)
library(treeio)
library(ggnewscale)
library(vegan)
library(multcompView)
library(ggridges)
#Set a random seed
set.seed(123)
#Make/call functions

```

```{r reading data, echo=FALSE,include=FALSE}
#Load in the necessary data files and reformat as necessary
metabolite_dictionary<-read.csv("./Data/all_max_flux_met_names_diamond.csv")
metabolite_info<-read.csv("Data/all_max_flux_diamond_transposed.csv")
file_headers<-read.csv("Data/all_max_flux_headers_diamond.csv")

#Prepare matrix for input into SOMs
metabolite_matrix<-as.matrix(metabolite_info[,-1])
dimnames(metabolite_matrix)<-list(as.matrix(file_headers[,2]),as.matrix(metabolite_dictionary[,2]))

#Read in information of the reaction frequency for the genomes to subset a "high quality" set of genomes
rxn_freq_info<-read.csv("Data/rxn_info.csv")
thresh<-0.8

high.quality.genomes<-rxn_freq_info%>%filter(mean_freq>thresh)%>%select(X)%>%as.matrix()
subset_rows<-which(rownames(metabolite_matrix)%in%high.quality.genomes)
metabolite_matrix<-metabolite_matrix[subset_rows,]

#Need to remove any columns with no flux in any models
zerofluxes<-which(colSums(metabolite_matrix)==0)
if (is_empty(zerofluxes)==FALSE){
  metabolite_matrix<-metabolite_matrix[,-zerofluxes]
}

#We will apply a double scaling where we also normalize the row sums to be all the same
rowscaled_matrix<-metabolite_matrix/rowSums(metabolite_matrix)
# scaled_matrix<-scale(rowscaled_matrix)

# col.maxes<-apply(rowscaled_matrix,2,max)
# scaled_matrix<-mapply('/',data.frame(rowscaled_matrix),col.maxes)
scaled_matrix<-scale(rowscaled_matrix)


#We would like to remove certain metabolites we don't think are super interesting and have been shown to drive SOM patterns
remove_metab<-which(colnames(scaled_matrix) %in% c("Manganese","Zinc","Co2+","Calcium","Chloride","Potassium","Copper","Cu+","Magnesium","O2 O2"))
metabolite_matrix<-metabolite_matrix[,-remove_metab]; scaled_matrix<-scaled_matrix[,-remove_metab]
rownames(scaled_matrix)<-rownames(metabolite_matrix)

```

## 2    Methods

# Running Code
## Running the SOM clustering procedure with our given parameters.


```{r Run SOMs}
#Run SOMs, for the full scaled dataset we have selected a 9x8 grid but other grids are being tested
gridrows=10; gridcols=10; gridsize=gridrows*gridcols
initSOM(dimension=c(gridrows,gridcols),nb.save=10)
set.seed(123)
# carve.som<-trainSOM(x.data=scaled_matrix,nb.save=10,maxit=20000,scaling="none")

#Load in variables to save time when knitting
load("Data/all_carve-som-info_double-scale-hq.RData")

#Analyze SOMs
#Use superClass with a chosen k value (manually selected) and then index it to get the clusters for each genome
num_clusters=8
carve.sc<-superClass(carve.som,k=num_clusters)

clusters<-carve.sc$cluster
ids<-carve.sc$som$clustering
sample_clusters<-clusters[ids]

```

### SOM cluster analysis... done!

```{r SOM analysis, echo=FALSE}
#We also want to examine the recipes to find genomes where all or nearly all recipes are identical
genome_IDs<-unique(rownames(scaled_matrix))
dupe_count<-0
dupe_IDs<-c()
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(scaled_matrix) %in% curr_id)
  sub_mat<-scaled_matrix[curr_indices,]
  dupe_check<-unique(sub_mat)
  if (dim(dupe_check)[1]==1){
    print(paste("Dupe found in genome",curr_id))
    dupe_IDs<-cbind(dupe_IDs,curr_id)
    dupe_count<-dupe_count+1
  }
}

#Determine the majority cluster to which each genome belongs
majority_clust<-c()
set.seed(123)
tracker<-0
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(scaled_matrix) %in% curr_id)
  curr_clust<-sample_clusters[curr_indices]%>%table()
  
  major<-which(curr_clust %in% max(curr_clust)) %>% names(curr_clust)[.] %>% as.numeric()
  #There are a handful of models (14 in the current construction, 10x10 grid for the >50% genomes) that have two SOM clusters that tie for majority so we are randomly selecting in those cases
  if (length(major)==1){
    majority_clust<-c(majority_clust,major)
    tracker<-tracker+1
  } else {
    #Functionality to visualize the genomes with ties
    print(paste(curr_id,"has",length(major),"SOM clusters with",max(curr_clust),"models each."))
    #print(curr_clust)
    
    majority_clust<-c(majority_clust,sample(major,1))
  }
}
cluster_df<-as_tibble(genome_IDs)%>%mutate(.,clusters=majority_clust)

#We want to repeat this process for the majority SOM grid point which is more specific than SOM cluster
majority_gridpoint<-c()
set.seed(123)
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(scaled_matrix) %in% curr_id)
  curr_point<-ids[curr_indices]%>%table()
  
  major<-which(curr_point %in% max(curr_point)) %>% names(curr_point)[.] %>% as.numeric()
  #There are a handful of models (14 in the current construction, 10x10 grid for the >50% genomes) that have two SOM clusters that tie for majority so we are randomly selecting in those cases
  if (length(major)==1){
    majority_gridpoint<-c(majority_gridpoint,major)
  } else {
    #Functionality to visualize the genomes with ties
    print(paste(curr_id,"has",length(major),"SOM grid points with",max(curr_point),"models each."))
    #print(curr_clust)
    
    majority_gridpoint<-c(majority_gridpoint,sample(major,1))
  }
}
gridpoint_df<-as_tibble(genome_IDs)%>%mutate(.,gridpoints=majority_gridpoint)
gridpoint_table<-table(gridpoint_df$gridpoints)

data_pca<-prcomp(scaled_matrix)
points<-data_pca$x%>%as_tibble()%>%mutate(.,clusters=sample_clusters)
points$clusters<-as_factor(points$clusters)

pca_plot<-ggplot(points,aes(x=PC1,y=PC2,colour=clusters))+geom_point()+theme_bw()

#Now try reformulating the dataframe by metabolite and look at summary stats
scaled_df<-as_tibble(scaled_matrix)%>%mutate(.,clusters=sample_clusters,genomes=rownames(scaled_matrix))%>%
  pivot_longer(-c(clusters,genomes),names_to="metabolite",values_to="scaled_value")
scaled_df$clusters<-as_factor(scaled_df$clusters)

summarize_df<-scaled_df%>%group_by(clusters,metabolite)%>%summarize(mean=mean(scaled_value,na.rm=TRUE),std=sd(scaled_value,na.rm=TRUE))

# ggplot(summarize_df,aes(x=metabolite,y=mean,colour=clusters))+geom_point()+theme_bw()

#Repeating the above process but thresholding out metabolites
threshold_df<-summarize_df%>%filter(abs(mean)>0.01)

mean_flux_clust_plot<-ggplot(threshold_df,aes(x=metabolite,y=mean,colour=clusters))+geom_point()+theme_bw()+theme(axis.text.x=element_blank())+ylab("Scaled Mean Flux")

mean_versus_std_flux_plot<-ggplot(threshold_df,aes(x=mean,y=std,colour=clusters))+geom_point()+theme_bw()+xlab("Scaled Mean Flux")+ylab("Scaled Standard Deviation")

#We want to compute several metrics on the data itself to determine need for thresholding and excluding certain metabolites

#First we want to look at the average coefficients of variance per metabolite per genome (one value per genome)
#Use the genome IDs to subset all models for a genome
genome_IDs<-unique(rownames(metabolite_matrix))
average_coeffsvar<-vector(mode="integer",length=length(genome_IDs))
for (i in 1:length(genome_IDs)){
  curr_rows<-which(rownames(metabolite_matrix)==genome_IDs[i])
  curr_matrix<-metabolite_matrix[curr_rows,]
  #Need to remove metabolites that aren't present in any recipes
  zerocols<-which(colSums(curr_matrix)==0)
  curr_matrix<-curr_matrix[,-zerocols]
  
  #Now compute the coefficient of variance (mean/sd), need to also exclude zeros here in each column
  curr_means<-apply(curr_matrix,2,function(v) v[which(v>0)]%>%mean())
  curr_sds<-apply(curr_matrix,2,function(v) v[which(v>0)]%>%sd())
  #Any NA values reflect metabolites with only one non-zero flux so we will modify those to 0
  curr_sds[which(is.na(curr_sds)==TRUE)]<-0
  
  coeffs_var<-curr_sds/curr_means
  average_coeffsvar[i]<-mean(coeffs_var)
}

#Convert to a dataframe and plot as a histogram
coeffs_df<-as_tibble(average_coeffsvar)

coeffs_var_plot<-ggplot(coeffs_df,aes(x=value))+geom_histogram(color="blue",fill="white")+labs(x="Average Coefficient of Variance",y="Number of Genomes")+theme_bw()

#We want to look at the evenness of model distribution across the clusters to look for genomes to remove
ids<-carve.sc$som$clustering
sample_clusters<-clusters[ids]
counts_table<-vector(mode="integer",length=60)
for (i in 1:length(genome_IDs)){
  curr_rows<-which(rownames(scaled_matrix)==genome_IDs[i])
  curr_distr<-sample_clusters[curr_rows]%>%table()%>%unique()
  counts_table[curr_distr]<-counts_table[curr_distr]+1
}
evenness_df<-as_tibble(counts_table)

evenness_plot<-ggplot(evenness_df,aes(x=c(1:60),y=value))+
  geom_point()+
  labs(x="Number of replicates in cluster",y="Number of Genomes")+
  theme_bw()

#We also want to identify for different levels of K how much genome replicates are being split into multiple nodes
sizes<-c(2:20)
# genome_IDs<-unique(file_headers$model_name)
consensus<-matrix(data=0,nrow=length(sizes),ncol=1)
breadth<-matrix(data=0,nrow=length(sizes),ncol=1)
evenness<-matrix(data=0,nrow=length(sizes),ncol=1)
for (i in 1:length(sizes)){
  curr_size=sizes[i]
  curr.sc<-superClass(carve.som,k=curr_size)
  tmp_clusters<-curr.sc$cluster
  ids<-curr.sc$som$clustering
  tmp_sample_clusters<-tmp_clusters[ids]
  
  tmp.cons<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  tmp.breadth<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  tmp.evenness<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  for (j in 1:length(genome_IDs)){
    curr_genome<-genome_IDs[j]
    #curr.cons<-(which(file_headers$model_name %in% curr_genome)%>%sample_clusters[.]%>%table()%>%max())/60
    #curr.breadth<-(which(file_headers$model_name %in% curr_genome)%>%sample_clusters[.]%>%unique()%>%length())/60
    curr_cluster<-which(rownames(scaled_matrix) %in% curr_genome)%>%tmp_sample_clusters[.]
    curr.cons<-(curr_cluster%>%table()%>%max())/60
    curr.breadth<-(curr_cluster%>%unique()%>%length())/60
    if (length(table(curr_cluster))==1){
      curr.evenness<-1
    } else {
      curr.evenness<-(max(table(curr_cluster))-min(table(curr_cluster)))/60
    }
    
    tmp.cons[j]<-curr.cons
    tmp.breadth[j]<-curr.breadth
    tmp.evenness[j]<-curr.evenness
  }
  consensus[i]<-mean(tmp.cons)
  breadth[i]<-mean(tmp.breadth)
  evenness[i]<-mean(tmp.evenness)
}
consensus_df<-cbind(sizes,consensus,breadth,evenness)%>%as.data.frame()
colnames(consensus_df)<-c("Cluster Size","Consensus","Breadth","Evenness")
consensus_df<-consensus_df%>%pivot_longer(-c(`Cluster Size`),names_to="Metric",values_to="Value")

SOM_metrics_plot<-ggplot(consensus_df,aes(x=`Cluster Size`,y=Value,color=Metric))+geom_line()+ylim(0,1)+theme_bw()


```

### Tree generation... done!
```{r Big Tree, echo=FALSE}
source("Codes/phylo_code.R")

# pull in data

# tree <- read.tree("Data/source-genomes-GToTree_Output.tre")
tree <- read.iqtree("Data/Aligned_SCGs.faa.treefile")
tree <- as.phylo(tree)

phylo<-read.csv("Data/derep_all-GTDB-phylo_V2.tsv",sep="\t",header=TRUE)

split_phylo<-separate(phylo,GTDB.Taxonomy,sep=";",into=c("domain","phylum","class","order","family","genus","species"))
split_phylo<-split_phylo%>%rename("prokka_id"="Genome.prokka")

# pull out top 15 taxonomic groups

groups <- split_phylo %>% group_by(order) %>%
  summarise(count = n()) %>% arrange(desc(count))

groups$type <- "Other"
groups$type[1:15] <- groups$order[1:15]
groups$type <- gsub("o__","", groups$type)

split_phylo$group <- groups$type[match(split_phylo$order,groups$order)]

quality_data <- read.csv("Data/rxn_info.csv")

som_data <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(som_data)<-c("value","clusters")

# tree_wide <- as.tibble(tree)
# tree_wide$group <- split_phylo$group[match(tree_wide$label,split_phylo$prokka_id)]
# 
# tree_wide <- as.data.frame(tree_wide)

taxa_df <- data.frame(taxonomy = split_phylo$group[match(tree$tip.label, split_phylo$prokka_id)])
rownames(taxa_df) <- tree$tip.label
taxa_df$ref <- NA
taxa_df$ref[which(is.na(taxa_df$taxonomy))] <- "Reference Genomes"
taxa_df$taxonomy[which(taxa_df$taxonomy == "Other")] <- NA
ref_df <- data.frame(ref = taxa_df[,-1])
taxa_df$ref <- NULL
rownames(ref_df) <- tree$tip.label

labels <- data.frame(label = unique(taxa_df$taxonomy)) %>% arrange(label)

taxa_df$taxonomy <- factor(taxa_df$taxonomy,
                           levels = labels$label[1:15])

# convert back with as.phylo()

t_plot <- ggtree(tree, aes(x,y), layout = "circular", lwd = 0.05, branch.length = "none")

# t_plot <- rotate_tree(t_plot, 100)

out_tree <- gheatmap_hidden(t_plot, taxa_df, offset=-0.5, width=.025, colnames = FALSE) +
  scale_fill_manual(values = c("#c2532d","#706be1","#72d261",
                               "#632ea3","#c2cb52","#c850c9",
                               "#538542","#d24899","#63d4b8",
                               "#7e336e","#dba250","#4b488e",
                               "#83652a","#679ad8","#c98bce"), 
                     na.translate = FALSE) + 
  scale_color_manual(values = c("#c2532d","#706be1","#72d261",
                                "#632ea3","#c2cb52","#c850c9",
                                "#538542","#d24899","#63d4b8",
                                "#7e336e","#dba250","#4b488e",
                                "#83652a","#679ad8","#c98bce"), 
                    na.translate = FALSE) + labs(fill = "Taxonomy", color = "Taxonomy")

# align text to taxonomy
tree_dat <- out_tree$data %>% filter(isTip == TRUE)

tax_labs <- data.frame(id = tree$tip.label)
tax_labs$labs <- split_phylo$group[match(tax_labs$id,split_phylo$prokka_id)]
tax_labs$pos <- tree_dat$y[match(tax_labs$id, tree_dat$label)]

tax_sum <- tax_labs %>% group_by(labs) %>%
  summarise(pos = mean(pos)) %>% filter(!is.na(labs), labs != "Other")

tax_sum$angles = (tax_sum$pos/max(tax_labs$pos)) * 360

tax_sum$hshift <- 1

tax_sum$nchar <- nchar(tax_sum$labs)
tax_sum$nchar[which(tax_sum$angles < 90 | tax_sum$angles > 270)] <- NA
tax_sum$hshift[which(tax_sum$angles > 90 & tax_sum$angles < 270)] <- 0 
tax_sum$angles[which(tax_sum$angles > 90 & tax_sum$angles < 270)] <- tax_sum$angles[which(tax_sum$angles > 90 & tax_sum$angles < 270)] + 180
tax_sum$labs <- factor(tax_sum$labs,
                           levels = labels$label[1:15])

dist_max <- max(out_tree$data$x)

out_tree <- out_tree + geom_text(data = tax_sum, x = dist_max-5,
                     aes(y = pos, label = labs, angle = angles, hjust = hshift, color = labs),
                     vjust = 0.5, size = 4, fontface = "bold", show.legend = FALSE)

t_plot2 <- out_tree + new_scale_color() + new_scale_fill()

out_tree2 <- gheatmap2(t_plot2, ref_df, offset= -0.25, width=0.1, colnames = FALSE) +
  scale_fill_manual(values = c("red"), 
                    na.translate = FALSE) + 
  scale_color_manual(values = c("red"), 
                     na.translate = FALSE) + labs(fill = "", color = "") 

t_plot3 <- out_tree2 + new_scale_color() + new_scale_fill()

# quality data
quality_data$prokka_id <- paste0(quality_data$X,"-prokka")
qual_df <- data.frame(Quality = quality_data$mean_freq[match(tree$tip.label, quality_data$prokka_id)])
rownames(qual_df) <- tree$tip.label

out_tree3 <- gheatmap2(t_plot3, qual_df, offset= 12, width=0.05, colnames = FALSE) +
  scale_fill_viridis_c(na.value = "white", breaks = c(0,0.25,0.5,0.75,1)) + 
  scale_color_viridis_c(na.value = "white", breaks = c(0,0.25,0.5,0.75,1)) +
  # guides(color = guide_colorbar(title.hjust = 0.5, title.position = "top",
  #                               frame.colour = "black", ticks.colour = "black", barwidth = 10),
  #        fill = guide_colorbar(title.hjust = 0.5, title.position = "top",
  #                              frame.colour = "black", ticks.colour = "black",barwidth = 10)) +
  labs(fill = "Consensus", color = "Consensus") 

t_plot4 <- out_tree3 + new_scale_color() + new_scale_fill()

# now soms

som_data$prokka_id <- paste0(som_data$value,"-prokka")
som_df <- data.frame(som = som_data$clusters[match(tree$tip.label, som_data$prokka_id)])
rownames(som_df) <- tree$tip.label
som_df$som <- factor(som_df$som, levels = (1:num_clusters))

out_tree4 <- gheatmap2(t_plot4, som_df, offset= 18, width=0.05, colnames = FALSE) +
  scale_fill_manual(values = c("#ce4348",
                               "#6faf49",
                               "#8e66cb",
                               "#a18f3e",
                               "#cd52a3",
                               "#4aac8d",
                               "#cd763d",
                               "#688bcd",
                               "#bf6a83"), 
                    na.translate = FALSE) + 
  scale_color_manual(values = c("#ce4348",
                                "#6faf49",
                                "#8e66cb",
                                "#a18f3e",
                                "#cd52a3",
                                "#4aac8d",
                                "#cd763d",
                                "#688bcd",
                                "#bf6a83"), 
                     na.translate = FALSE) + labs(fill = "SOM Cluster", color = "SOM Cluster") +
  theme(legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.direction = "horizontal",
        legend.position = "bottom")


```

### Metabolite pattern analysis... done!

```{r Metabolite Classes, echo=FALSE}

#Single plot command to make violin plot of the total raw fluxes per cluster
raw_matrix<-as.data.frame(metabolite_matrix)%>%mutate(.,cluster=sample_clusters,total_flux=rowSums(metabolite_matrix))

raw_df<-raw_matrix%>%group_by(cluster)%>%summarise(flux_mean=mean(total_flux))

raw.flux_plot<-ggplot(raw_matrix,aes(x=as.factor(cluster),y=total_flux))+
  geom_violin(width=1)+
  stat_summary(fun="mean",geom="crossbar",color="black")+
  labs(x="Clusters",y="Total Flux")+
  geom_point(color="black")+
  theme_bw()

#We will now use manual classifications of key metabolites as identified within the thresholded group to coarse-grain our resolution of this issue for better data visualization
#Read in classifications
class_file<-read.csv("Data/classified_metabolites.csv")
class_df<-select(class_file,c(Metabolite,Higher.Level.Classification))

matching_classifiers<-which(class_df$Metabolite %in% unique(scaled_df$metabolite))
class_df<-class_df[matching_classifiers,]
classifications<-class_df$Higher.Level.Classification

#Now we want to match these to the metabolites in our threshold df and re-plot
metab_matches<-match(scaled_df$metabolite,class_df$Metabolite)
scaled_df$metab_class<-class_df$Higher.Level.Classification[metab_matches]

#Version of plots designed to do metabolite classes
#Create the prototypes dataframe, then modify it down to metabolite classes by averaging
df <- carve.som$prototypes %>% as.data.frame()
classifiers_df<-data.frame(nodes=rownames(df))
for (i in 1:length(unique(class_df$Higher.Level.Classification))){
  curr_class<-unique(class_df$Higher.Level.Classification)[i]
  metab_indices<-which(class_df$Higher.Level.Classification %in% curr_class)
  metab_matches<-match(class_df$Metabolite[metab_indices],colnames(df))
  metab_matches<-metab_matches[which(colSums(df[,metab_matches])!=0)]
  if (length(metab_matches)>1){
    classifiers_df<-mutate(classifiers_df,!!curr_class:=rowMeans(df[,metab_matches]))
  } else {
    classifiers_df<-mutate(classifiers_df,!!curr_class:=mean(df[,metab_matches]))
  }
}

classifiers_df$cluster <- carve.sc$cluster

classifiers_df$row_names <- rep(1:gridcols,times = gridrows)
classifiers_df$column_names <- rep(1:gridrows,each = gridcols)

min_vals<-apply(classifiers_df[5:17],2,min)

classifiers_df<-classifiers_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

#Create the wedge plots for every point in the SOM cluster with wedges for each metabolite class
pivot_df<-classifiers_df %>% pivot_longer(-c(nodes, cluster, row_names, column_names),
                                    names_to = "metab_class", values_to = "scaled_flux") %>%
  group_by(nodes) %>% mutate(min = min(scaled_flux),
                             max = max(scaled_flux),
                             polar_size = (scaled_flux)/(abs(max)+abs(min)))

pivot_df$metabolite <- factor(pivot_df$metab_class, levels = unique(pivot_df$metab_class))

#Plot density ridges of the SOM prototypes per cluster
ggplot(data=pivot_df,aes(x=scaled_flux,y=as.factor(cluster),fill=as.factor(cluster)))+geom_density_ridges(scale=0.9)+facet_wrap(~metab_class,scales="free_x")+theme(legend.position="none")+labs(x="Prototype scaled flux",y="Cluster")

plot_df = pivot_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = metab_class, y = polar_size, fill = metab_class) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1) +
                       coord_polar() +
                       scale_fill_manual(values = c("#7663cf",
                                                    "#8db43b",
                                                    "#c851b1",
                                                    "#55bc63",
                                                    "#d54767",
                                                    "#4fbeae",
                                                    "#d15236",
                                                    "#588dcc",
                                                    "#d2a23a",
                                                    "#a879bf",
                                                    "#458149",
                                                    "#bd6484",
                                                    "#89883f",
                                                    "#ba7648"))))

plot_df$row_names <- rep(1:gridcols,times = gridrows)
plot_df$column_names <- rep(1:gridrows,each = gridcols)

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.5, xmax = ..1+0.5,
                                               ymin = ..2-0.5, ymax = ..2+0.5))) %>%
  pull(annotation)


grid_plot <- ggplot() + 
  geom_point(data = classifiers_df[,1:4], aes(x = column_names, y = row_names,color=as.factor(cluster)),
             pch = 21, size = 25,stroke=2) +
  geom_col(data = pivot_df,
           aes(0,0, fill = metab_class)) +
  coord_cartesian(expand = 1.4) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5)) +
  scale_fill_manual(values = c("#7663cf",
                               "#8db43b",
                               "#c851b1",
                               "#55bc63",
                               "#d54767",
                               "#4fbeae",
                               "#d15236",
                               "#588dcc",
                               "#d2a23a",
                               "#a879bf",
                               "#458149",
                               "#bd6484",
                               "#89883f",
                               "#ba7648")) + labs(color="Cluster",fill = "Metabolite Class") + 
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5))

#Further plots based on the metabolite classes for all som grid points
#Create a new dataframe where you take means and standard deviations for SOM prototypes in each cluster, all metabolite classes per cluster
metab_classes<-unique(class_df$Higher.Level.Classification)
metab_mat<-c()
for (i in 1:num_clusters){
  curr_means<-filter(classifiers_df,cluster==i)%>%select(!c(nodes,cluster,row_names,column_names))%>%colMeans(.)
  curr_sds<-filter(classifiers_df,cluster==i)%>%select(!c(nodes,cluster,row_names,column_names))%>%apply(.,2,sd)
  metab_mat<-rbind(metab_mat,cbind(metab_classes,curr_means,curr_sds))
}
metab_df<-as.data.frame(metab_mat)
colnames(metab_df)<-c("Metabolite Class","means","sds") ; rownames(metab_df)<-c()
metab_df$means<-as.numeric(metab_df$means) ; metab_df$sds<-as.numeric(metab_df$sds)

metab_df$cluster<-rep(1:num_clusters,each=length(metab_classes))
metab_df$node<-rep(1:num_clusters,each=length(metab_classes))

metab_df$cluster <- factor(metab_df$cluster)

metab_order <- metab_df %>% group_by(`Metabolite Class`) %>%
  summarise(rank = mean(abs(means), na.rm = TRUE)) %>% arrange(desc(rank))

metab_df$`Metabolite Class` <- factor(metab_df$`Metabolite Class`,
                                     levels = metab_order$`Metabolite Class`)

#Subset metabolite df to remove some uninteresting metabolite classes
sub.metab_df<-metab_df%>%filter(!(`Metabolite Class`%in%c("Other","Inorganic","Phospholipids/Fatty Acids/Triglycerides")))

cluster_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = sub.metab_df, aes(y = means, x = cluster, fill = cluster),
           stat = "identity") +
  geom_errorbar(data = sub.metab_df, aes(x = cluster,ymin = means-sds, ymax = means+sds),
                width = 0.2) +
  facet_wrap(vars(`Metabolite Class`)) +
  labs(x = "", y= "Scaled Flux", fill = "Cluster") +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size =12),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 10),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(0.85,0.05),
        legend.justification = c(1,0),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 1))

new_df <- metab_df %>% group_by(`Metabolite Class`) %>%
  mutate(scaled_flux = ((means - min(means-sds))/(max(means+sds)-min(means-sds))))

new_df$`Metabolite Class` <- factor(new_df$`Metabolite Class`,
                                     levels = metab_order$`Metabolite Class`)

#Line to subset the data frame for only specific metabolite classes
classes<-levels(new_df$`Metabolite Class`)[c(1,2,3,4,5,6,8)]
pared_df<-new_df[new_df$`Metabolite Class` %in% classes,]

flux_bubble_plot <- ggplot() +
  geom_vline(xintercept = factor(1:num_clusters), lty = 2, linewidth = 0.25) +
  geom_point(data = pared_df, aes(x = cluster, y = `Metabolite Class`, fill = means, size = scaled_flux), pch=21) +
  scale_size_continuous(range = c(0.01,10), limits = c(0,1), guide = "none") +
  labs(x = "Cluster", fill = "Scaled Flux", size = "Relative Flux") +
  scale_fill_gradientn(colours = c("blue","white","red"), 
                       values = scales::rescale(c(-0.15,0,0.15)),
                       guide = "colorbar", limits=c(-0.15,0.15), breaks = c(-0.15,0,0.15)) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"))

#We also want to try to make a version where we only display the average relative flux values for each 
#Create a mean df from the classifiers df
all_means<-c()
for (i in 1:num_clusters){
  curr_means<-filter(classifiers_df,cluster==i)%>%select(!c(nodes,cluster,row_names,column_names))%>%colMeans(.)
  all_means<-rbind(all_means,curr_means)
}
mean_df<-as.data.frame(all_means,row.names = FALSE)

mean_df$nodes<-c(1:num_clusters)
mean_df$row_names<-c(1,2,3,1,2,3,1,2)
mean_df$column_names<-c(1,1,1,2,2,2,3,3)
mean_df$cluster<-c(1:num_clusters)

#Optional block of code for if you want to threshold

mean_df<-mean_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

pivot.mean_df<-mean_df %>% pivot_longer(-c(nodes, cluster, row_names, column_names),
                                          names_to = "metab_class", values_to = "scaled_flux") %>%
  group_by(nodes) %>% mutate(min = min(scaled_flux),
                             max = max(scaled_flux),
                             polar_size = (scaled_flux)/(abs(max)+abs(min)))

pivot.mean_df$metabolite <- factor(pivot.mean_df$metab_class, levels = unique(pivot.mean_df$metab_class))

plot_df = pivot.mean_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = metab_class, y = polar_size, fill = metab_class) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1) +
                       coord_polar() +
                       scale_fill_manual(values = c("#7663cf",
                                                    "#8db43b",
                                                    "#c851b1",
                                                    "#55bc63",
                                                    "#d54767",
                                                    "#4fbeae",
                                                    "#d15236",
                                                    "#588dcc",
                                                    "#d2a23a",
                                                    "#a879bf",
                                                    "#458149",
                                                    "#bd6484",
                                                    "#89883f",
                                                    "#ba7648"))))

plot_df$row_names <- c(1,2,3,1,2,3,1,2)
plot_df$column_names <- c(1,1,1,2,2,2,3,3)

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.5, xmax = ..1+0.5,
                                               ymin = ..2-0.5, ymax = ..2+0.5))) %>%
  pull(annotation)


flux_abund_plot <- ggplot() + 
  geom_point(data = mean_df[,1:4], aes(x = column_names, y = row_names,color=as.factor(cluster)),
             pch = 21, size = 50,stroke=2) +
  geom_col(data = pivot.mean_df,
           aes(0,0, fill = metab_class)) +
  coord_cartesian(expand = 10) +
  expand_limits(x=5,y=5) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5)) +
  scale_fill_manual(values = c("#7663cf",
                               "#8db43b",
                               "#c851b1",
                               "#55bc63",
                               "#d54767",
                               "#4fbeae",
                               "#d15236",
                               "#588dcc",
                               "#d2a23a",
                               "#a879bf",
                               "#458149",
                               "#bd6484",
                               "#89883f",
                               "#ba7648")) + labs(color="Cluster",fill = "Metabolite Class") + 
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5),color=guide_legend(title.position="top",override.aes=list(size=20)))

```

### Phylogenetic analysis... done!

```{r phylogeny, echo=FALSE}
#Code to examine the phylogeny of SOM clusters
#Load phylogeny and match it to genome IDs
phylo<-read.csv("Data/derep_all-GTDB-phylo_V2.tsv",sep="\t",header=TRUE)

split_phylo<-separate(phylo,GTDB.Taxonomy,sep=";",into=c("domain","phylum","class","order","family","genus","species"))
groups<-split_phylo%>%group_by(order)%>%summarise(count=n())%>%arrange(desc(count))

groups$type<-"Other"
groups$type[1:15]<-groups$order[1:15]
groups$type<-gsub("o__","",groups$type)
split_phylo$Genome.prokka<-gsub("-prokka","",split_phylo$Genome.prokka)
split_phylo$group<-groups$type[match(split_phylo$order,groups$order)]

#Isolate the correct subset of genomes and reduce the dataframe to match
split_phylo_hq<-split_phylo[split_phylo$Genome.prokka %in% genome_IDs,]%>%select(Genome.prokka,group)

#Regenerate a superClass object of the correct value K
carve.sc<-superClass(carve.som,k=num_clusters)
clusters<-carve.sc$cluster
ids<-carve.sc$som$clustering
sample_clusters<-clusters[ids]

#Use the majority clustering previously calculated to assign a cluster to each genome
match_rows<-match(split_phylo_hq$Genome.prokka,genome_IDs)
split_phylo_hq<-mutate(split_phylo_hq,cluster=majority_clust[match_rows])
phylo_mat<-matrix(data=0,nrow=num_clusters,ncol=16)
colnames(phylo_mat)<-unique(split_phylo_hq$group)
for (i in 1:num_clusters){
  curr_cluster<-split_phylo_hq%>%select(cluster,group)%>%filter(cluster==i)
  curr_phylo<-table(curr_cluster$group)
  phylo_cols<-match(names(curr_phylo),colnames(phylo_mat))
  phylo_mat[i,phylo_cols]<-curr_phylo
}
phylo_df<-as.data.frame(phylo_mat,row.names = FALSE)%>%mutate(.,cluster=c(1:num_clusters))%>%select(cluster,everything())

# ggplot(filter(phylo_df,cluster==1),aes(x="",y=value,fill=group))+
#   geom_col(color="black")+
#   geom_text(aes(x=1.35,label=value),position=position_stack(vjust=0.5))+
#   coord_polar(theta="y")+
#   theme_void()

#Now we want to plot all the pie charts together
phylo_df$nodes<-c(1:num_clusters)
phylo_df$row_names<-c(1,2,3,1,2,3,1,2)
phylo_df$column_names<-c(1,1,1,2,2,2,3,3)
phylo_df$cluster<-c(1:num_clusters)

#Optional block of code for if you want to threshold

phylo_df<-phylo_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

pivot_df<-phylo_df %>% pivot_longer(-c(nodes, cluster, row_names, column_names),
                                   names_to = "Group", values_to = "Number of Genomes") %>%
  group_by(nodes)

pivot_df$Order <- factor(pivot_df$Group, levels = unique(pivot_df$Group))

plot_df = pivot_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = "", y = `Number of Genomes`, fill = Order)+
                       geom_col(color="black",show.legend=FALSE)+
                         coord_polar(theta="y")+
                       scale_fill_manual(values=c("#b8617c",
                                                  "#63b750",
                                                  "#895bc9",
                                                  "#b2b53b",
                                                  "#c84ca3",
                                                  "#3d854f",
                                                  "#d74164",
                                                  "#54bf9f",
                                                  "#cf5230",
                                                  "#54acd8",
                                                  "#d48e36",
                                                  "#5f7ac7",
                                                  "#6e772c",
                                                  "#bf83c9",
                                                  "#bca262",
                                                  "#b7694b"))))

pivot_df <- pivot_df %>% group_by(cluster) %>% mutate(perc = `Number of Genomes`/sum(`Number of Genomes`))

order_df <- pivot_df %>% group_by(Order) %>% summarise(mean = mean(perc)) %>%
  arrange(mean)

pivot_df$Order <- factor(pivot_df$Order, levels = order_df$Order)

phylo_abund_plot<-ggplot(pivot_df, aes(x = as.factor(cluster), y = perc, fill = Order)) +
  geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "Cluster", y = "Proportion")+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b"))

plot_df$row_names <- (c(1,2,3,1,2,3,1,2)-1)*2+0.55
plot_df$column_names <- (c(1,1,1,2,2,2,3,3)-1)*2+0.25
plot_df$cluster<-phylo_df$cluster
plot_df<-select(plot_df,nodes,cluster,row_names,column_names,everything())

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.9, xmax = ..1+0.9,
                                               ymin = ..2-0.9, ymax = ..2+0.9))) %>%
  pull(annotation)


phylo_grid_plot <- ggplot() +
  geom_col(data = pivot_df,
           aes(0,0, fill = Order))+
  geom_point(data = plot_df[,1:4], aes(x = column_names, y = row_names,color=as.factor(cluster)),
             pch = 21, size = 82.5,stroke=2)+
  coord_cartesian(expand = 10) +
  expand_limits(x=5,y=5) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5))+ 
        labs(color="Cluster")+
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5),color=guide_legend(title.position="top",override.aes=list(size=20)))+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b")) 

# print("Figure: ")
# plot(phylo_grid_plot)

#Try re-plotting this with one bar per phylogenetic order per cluster
phylo_stacked_abund_plot<-ggplot(pivot_df, aes(y = Order, x = perc, fill = as.factor(cluster))) +
  geom_bar(position="dodge",stat = "identity") + coord_cartesian(expand = FALSE) + labs(y = "Cluster", x = "Proportion", fill="Cluster")+
  scale_fill_manual(values = c("#ce4348",
                               "#6faf49",
                               "#8e66cb",
                               "#a18f3e",
                               "#cd52a3",
                               "#4aac8d",
                               "#cd763d",
                               "#688bcd",
                               "#bf6a83"))

#Now try re-plotting the same style chart but we want to compute a new metric -> relative abundance of orders in cluster compared to relative abundance of order in total dataset
#Get the whole data order abundances
fulldata_abundances<-table(split_phylo_hq$group)%>%as.data.frame()
colnames(fulldata_abundances)<-c("Order","Abundance")
fulldata_abundances<-mutate(fulldata_abundances,Abundance=Abundance/length(genome_IDs))

#Now we want to compute the ratio between the within cluster abundances and full data abundances
pivot_df$diff<-0
for (i in 1:length(fulldata_abundances$Order)){
  pivot_df<-pivot_df%>%mutate(diff=ifelse(Order==fulldata_abundances$Order[i],(perc/fulldata_abundances$Abundance[i])-1,diff))
}

#Now plot
phylo_rel_diff_plot<-ggplot(pivot_df, aes(y = as.factor(cluster), x = diff, fill = as.factor(cluster))) +
  geom_bar(width=0.65,position="dodge",stat = "identity") + scale_x_continuous(expand=expansion(mult=c(0,0.1))) + labs(y = "Cluster", x = "Difference from Full Data (% change rel abundance)", fill="Cluster")+
  theme_bw()+facet_wrap(~Order)

#Now we will look at some more traditional metrics at different taxonomic levels of resolution
load("Output/genus_by-Ksize_hq-genomes.RData")
bray_phylo<-bray_phylo%>%filter(Genome.prokka%in%genome_IDs)

phylo_piv <- bray_phylo[,2:13] %>% pivot_longer(-group, names_to = "K", values_to = "cluster") %>% 
  group_by(group,K,cluster) %>% summarise(count = n()) %>%
  group_by(K,cluster) %>% mutate(sum = sum(count)) %>%
  group_by(K,cluster,group) %>% mutate(prop = count/sum) 

bray_list <- list()

for (k in 2:12) {
  
  sub_df <- phylo_piv %>% filter(K == paste0("Cluster ",k))
  sub_df <- sub_df[,c("group","cluster","count")]
  sub_df <- sub_df %>% pivot_wider(names_from = "cluster", values_from = "count",values_fill = 0)
  sub_df$group <- NULL
  sub_df <- t(sub_df)
  bray <- vegdist(sub_df[,-1],method = "bray", upper = FALSE, diag = FALSE)
  bray <- as.matrix(bray)
  bray[lower.tri(bray,diag = TRUE)] <- NA
  bray <- as.data.frame(bray)
  bray$cluster1 <- rownames(bray)
  
  bray <- bray %>% pivot_longer(-cluster1, names_to = "cluster2", values_to = "bray") %>% filter(!is.na(bray))
  bray$K <- k
  bray_list[[k-1]] <- bray
  
}


bray_df <- do.call(rbind.data.frame, bray_list)
bray_df$bray <- 1-bray_df$bray

bray_plot<-ggplot(bray_df, aes(x = as.factor(K), y = bray)) + geom_violin(width = 1) +
  geom_jitter(width = 0.05) + labs(x = "K Value", y = "Bray-Curtis Similarity") +
  theme_bw() + theme(text = element_text(size = 15))

```

### Growth estimate (dCUB) analysis... done!

```{r Growth Data, echo=FALSE, fig.width=12, fig.height=12}
#Plot a grid map with genomes as density, growth rates as a heatmap and colored borders by cluster

asinh_trans = function(){
  scales::trans_new("asinh",
                    transform = asinh,
                    inverse = sinh)

}

growth_dat<-read.csv("Data/growth_violin_data.csv")

#Plot the growth rate distributions for each cluster (ideally add in statistical sig as well)
growth_df<-cluster_df
growth_df<-mutate(growth_df,matchrow=match(cluster_df$value,growth_dat$Genome,nomatch=0))
replace_rows<-which(growth_df$matchrow>0)
growth_df<-growth_df%>%filter(.,matchrow>0)%>%mutate(dCUB=growth_dat$dCUB[matchrow])%>%select(-c(matchrow))
growth_df$clusters<-as.factor(growth_df$clusters)

#Compute a tukey test on the samples grouped by cluster to see if any clusters are significantly different from one another
model=lm(growth_df$dCUB ~ growth_df$clusters)
ANOVA=aov(model)

TUKEY<-TukeyHSD(x=ANOVA,'growth_df$clusters',conf.level=0.95)
Tukey.levels<-TUKEY[["growth_df$clusters"]][,4]
Tukey.labels<-data.frame(multcompLetters(Tukey.levels)['Letters'])
Tukey.labels$treatment<-rownames(Tukey.labels)
Tukey.labels<-Tukey.labels[order(Tukey.labels$treatment),]
numeric.labels<-match(Tukey.labels[,1],unique(Tukey.labels[,1]))

growth_df<-growth_df%>%mutate(group=numeric.labels[clusters])

#We'd also like to do a comparison between the flux and growth rates by cluster to see if differentiation among slow clusters could be flux driven
avg_df<-metab_df%>%group_by(cluster)%>%summarise(flux_mean=mean(means))
avg_df<-avg_df%>%mutate(.,growth_mean=growth_df%>%group_by(clusters)%>%summarise(mean=mean(dCUB))%>%select(mean)%>%as.matrix()%>%as.numeric())
avg_df<-avg_df%>%mutate(tukey_groups=as.factor(numeric.labels))

growth_violin_plot<-ggplot(growth_df,aes(x=as.factor(clusters),y=dCUB,color=as.factor(group)))+
  geom_violin(width=1)+
  stat_summary(fun="mean",geom="crossbar",color="black")+
  labs(x="Clusters")+
  scale_color_discrete(name="Group",labels=unique(Tukey.labels[,1]))+
  geom_point()+
  geom_point(data=avg_df,aes(x=cluster,y=(flux_mean-max(flux_mean))/abs((min(flux_mean)-max(flux_mean)))),color="black",size=3,shape=22,fill="black")+
  theme_bw()

pivot.avg_df<-avg_df%>%pivot_longer(-c(cluster,tukey_groups))

flux_versus_growth_plot<-ggplot()+
  geom_point(data=pivot.avg_df,aes(x=cluster,y=value,color=tukey_groups,shape=name),size=4)+
  theme_bw()

#Construct a dataframe of the per SOM grid point growth information
df <- carve.som$prototypes %>% as.data.frame()
classifiers_df<-data.frame(nodes=rownames(df))%>%mutate(.,growth=0,`Number Genomes`=0)
classifiers_df$`Number Genomes`[names(gridpoint_table)%>%as.numeric()]<-gridpoint_table
for (i in 1:length(unique(gridpoint_df$gridpoints))){
  curr_point<-unique(gridpoint_df$gridpoints)[i]
  point_indices<-which(gridpoint_df$gridpoints %in% curr_point)
  point_matches<-match(gridpoint_df$value[point_indices],growth_dat$X,nomatch=0)
  point_matches<-which(point_matches>0)%>%point_matches[.]
  if (length(point_matches)>1){
    classifiers_df$growth[curr_point]<-mean(growth_dat$dCUB[point_matches])
  } else if (length(point_matches)==1) {
    classifiers_df$growth[curr_point]<-growth_dat$dCUB[point_matches]
  }
}

#Change any zero entries to NA
zero_loc<-which(classifiers_df$growth==0)
classifiers_df$growth[zero_loc]<-NA

classifiers_df$cluster <- carve.sc$cluster

classifiers_df$row_names <- rep(1:gridcols,times = gridrows)
classifiers_df$column_names <- rep(1:gridrows,each = gridcols)

classifiers_df<-classifiers_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

#Create a dataframe object that will draw the boxes around the cluster nodes
cluster_squares_df<-data.frame(cluster=c(1:num_clusters))
cluster_squares_df<-mutate(cluster_squares_df,xmin=0,xmax=0,ymin=0,ymax=0)
for (i in 1:num_clusters){
  curr_clust<-i
  curr_points<-filter(classifiers_df,cluster==i)%>%select(row_names,column_names)
  xmin=min(curr_points$column_names -0.4); xmax=max(curr_points$column_names +0.4); ymin=min(curr_points$row_names -0.4); ymax=max(curr_points$row_names +0.4)
  cluster_squares_df[i,c("xmin","xmax","ymin","ymax")]<-c(xmin,xmax,ymin,ymax)
}

som_grid_plot<-ggplot() +
  geom_rect(data=cluster_squares_df,mapping=aes(xmin=xmin, xmax = xmax, ymin = ymin, ymax= ymax,color=as.factor(cluster)),fill= "white", lwd = 2) +
  geom_point(data= classifiers_df,aes(x = column_names, y = row_names, size = `Number Genomes`,fill=growth),pch=21,stroke=1) +
  scale_fill_gradientn(colors = c("red","white","blue"), values = scales::rescale(c(-0.25,-0.09833212,-0.08)),
                       guide = "colorbar", limits=c(-0.25,-0.08), 
                       breaks = c(-0.25,-0.15,-0.08), labels = c("<-0.25","-0.15",">-0.08"),
                       oob = scales::squish, trans = asinh_trans()) +
  scale_size_continuous(range=c(4,14),breaks = c(0,150,300))+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom", legend.key = element_blank(),
        legend.box = "vertical")+
  guides(color=guide_legend(override.aes=list(size=5)))+
  labs(size="Number of Genomes",fill="dCUB value",color="Cluster")+
  coord_equal()

#Now plot the metabolite dependence data, contextualize by growth
grow_df <- read.csv("Data/growth_info_all_mets_20231030.csv")
grow_df<-grow_df[,c(1,match(genome_IDs,colnames(grow_df)))]
clust_df <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(clust_df)<-c("value","clusters")
# load("Data/mean_raw-flux-values_by-metabolite_by-cluster_80pt-K8.RData")
mean_df<-mean_df%>%select(-c(Inorganic))

colnames(grow_df)[1] <- "metabolite_class"

grow_df <- grow_df %>% pivot_longer(-metabolite_class, names_to = "genome",values_to = "growth_req") %>%
  filter(metabolite_class != "Inorganic",growth_req>=-0.001)

grow_df$cluster <- clust_df$clusters[match(grow_df$genome,clust_df$value)]%>%as.factor()
grow_df$metabolite_class<-factor(grow_df$metabolite_class,levels=unique(grow_df$metabolite_class))

all.deps_density<-ggplot(data=filter(grow_df,growth_req>=0),aes(x=growth_req,y=cluster,fill=cluster))+geom_density_ridges(stat="binline",scale=0.9)+facet_wrap(~metabolite_class)+theme_bw()+theme(legend.position="none")

sum_grow <- grow_df %>% group_by(cluster, metabolite_class) %>%
  summarise(avg_grow_req = mean(growth_req, na.rm = TRUE)) 

grow_order <- grow_df %>% group_by(metabolite_class) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

sum_grow$cluster <- factor(sum_grow$cluster)
sum_grow$metabolite_class <- factor(sum_grow$metabolite_class, levels = grow_order$metabolite_class)

out_grow <- ggplot(sum_grow, aes(y = metabolite_class, x = avg_grow_req, fill = cluster)) +
  geom_bar(stat= "identity", position = "dodge") + scale_x_continuous(expand = c(0,0), limits = c(0,1)) +
  labs(x = "Potential Growth Limitation", y= "", fill = "Som Cluster") + 
  theme(legend.position = c(0.97,0.97),
        legend.justification = c(1,1),
        legend.title = element_text(size = 12, angle = 90),
        legend.text = element_text(size =12),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 12),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        legend.background = element_rect(fill = "white", color = "black")) +
  guides(fill = guide_legend(title.position = "left", title.hjust = 0.5)) +
  geom_hline(yintercept = seq(1.5,11.5), lty = 2, lwd = 0.25) + ggtitle("A")

sum_grow <- sum_grow %>% group_by(metabolite_class) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req)))) 
  

growth_dep_plot <- ggplot(sum_grow, aes(x = cluster, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(guide = "none", range = c(2,10)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black")) +
  labs(x = "Cluster", fill = "Average Growth Requirement")

# compare plot
piv.mean_df <- mean_df[,c(2,5:16)] %>% pivot_longer(-cluster, names_to = "metabolite_class", values_to = "flux")
piv.mean_df$cluster <- factor(piv.mean_df$cluster)
comb_df <- full_join(sum_grow, piv.mean_df)

comb_df$metabolite_class[which(comb_df$metabolite_class == "Nucleobases/Nucleosides/Nucleotides/Derivatives")] <- "Nucleobases/Nucleosides/\nNucleotides/Derivatives"
comb_df$metabolite_class[which(comb_df$metabolite_class == "Phospholipids/Fatty Acids/Triglycerides")] <- "Phospholipids/\nFatty Acids/Triglycerides"

met_names <- sort(unique(comb_df$metabolite_class))
comb_df$metabolite_class <- factor(comb_df$metabolite_class, levels = met_names[c(1:9,11:12,10)])

# plot regression lines
flux_versus_dep_plot<-ggplot(comb_df, aes(x = flux, y = avg_grow_req, color = cluster)) +
  geom_point(size = 4, alpha = 0.75) + facet_wrap(~metabolite_class, scales = "free_x") +
  labs(color = "Metabolite Class", x = "Flux", y = "Potential Growth Limitation") +
  theme(panel.background = element_blank(), panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 10),
        legend.key = element_blank(),
        legend.position = "bottom",
        legend.direction = "horizontal") + 
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 1))

#Incomplete piece of code for plotting model growth rates against dCUB, need to recreate the hq.genomes_all.info data frame

# no.NAs_data<-hq.genomes_all.info_df%>%filter(dCUB!="NA")
# 
# groups<-no.NAs_data%>%group_by(Order)%>%summarise(count=n())%>%arrange(desc(count))
# 
# groups$type<-"Other"
# groups$type[1:15]<-groups$Order[1:15]
# groups$type<-gsub("o__","",groups$type)
# no.NAs_data$group<-groups$type[match(no.NAs_data$Order,groups$Order)]
# 
# ggplot()+
#   geom_point(data=no.NAs_data,aes(x=dCUB,y=`model growth`,group=as.factor(group),color=as.factor(cluster)))+
#   theme_bw()+
#   facet_wrap(~group)

#New version of bubble plot that tries to combine information from several plots. Want to try the metabolite dependence values as color and mean scaled fluxes as size
sum_grow$mean_flux<-new_df%>%ungroup%>%filter(`Metabolite Class`!="Inorganic")%>%select(means)%>%as.matrix()%>%as.numeric()
sum_grow$scaled_flux<-new_df%>%ungroup%>%filter(`Metabolite Class`!="Inorganic")%>%select(scaled_flux)%>%as.matrix()%>%as.numeric()

growth_dep_flux.size_plot <- ggplot(sum_grow, aes(x = cluster, y = metabolite_class, size = scaled_flux, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(range = c(0.01,10),limits=c(0,1)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"),size=guide_legend(title.position="top",title.hjust=0.5)) +
  labs(x = "Cluster", fill = "Average Growth Requirement",size="Relative Scaled Flux")

#Also want to try plotting metabolite dependence in a few different arrangements, by total dependence and by growth (low to high)
#Match up the genomes from the grow_df to the phylo df
match_grow<-match(grow_df$genome,split_phylo_hq$Genome.prokka)
grow_df$group<-split_phylo_hq$group[match_grow]

sum.taxa_df<-grow_df%>%group_by(metabolite_class,group)%>%summarise(avg_grow_req=mean(growth_req,na.rm=TRUE))

taxa.grow_order <- grow_df %>% group_by(group) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

sum.taxa_df$metabolite_class<-factor(sum.taxa_df$metabolite_class); sum.taxa_df$group<-factor(sum.taxa_df$group,levels=taxa.grow_order$group)

sum.taxa_df <- sum.taxa_df %>% group_by(group) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req)))) 

growth_dep_by.phylo_plot <- ggplot(sum.taxa_df, aes(x = group, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(range = c(0.01,10),limits=c(0,1)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.text.x=element_text(angle=45,hjust=1),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"),size=guide_legend(title.position="top",title.hjust=0.5)) +
  labs(x = "Order", fill = "Average Growth Requirement",size="Relative Growth")

```

### Sub-clustering analysis... done!

```{r Sub-clustering, echo=FALSE}

#We want to specifically examine the phylogeny of sub-groups of grid points within individual SOM clusters.

sub.clust_phylo_df<-c()
for (curr_clust in 1:num_clusters){
  # curr_mean<-growth_df%>%filter(clusters==curr_clust)%>%ungroup()%>%select(dCUB)%>%as.matrix()%>%mean()
  # curr_mean<-mean(growth_df$dCUB)
  curr_mean=-0.08
  
  cluster_genomes<-growth_df%>%filter(clusters==curr_clust)%>%ungroup()%>%select(value,dCUB)
  
  #Split genomes based on growth
  high_growth_genomes<-cluster_genomes%>%filter(dCUB<curr_mean)%>%select(value)%>%as.matrix()
  low_growth_genomes<-cluster_genomes%>%filter(dCUB>=curr_mean)%>%select(value)%>%as.matrix()
  
  #Now find their phylogeny and plot it in terms of relative abundance
  high_growth_df<-cbind(high_growth_genomes,"high growth"); low_growth_df<-cbind(low_growth_genomes,"low growth")
  
  compare.grow_df<-as.data.frame(rbind(low_growth_df,high_growth_df)); colnames(compare.grow_df)<-c("Genome","Treatment")
  
  #Now add the relevant phylogeny to this dataframe
  phylo_mat<-matrix(data=0,nrow=2,ncol=16)
  colnames(phylo_mat)<-unique(split_phylo_hq$group)
  for (i in c("low growth","high growth")){
    if (i =="low growth"){
      genomes<-low_growth_genomes
      count<-1
    } else {
      genomes<-high_growth_genomes
      count<-2
    }
    curr_group<-split_phylo_hq%>%filter(., Genome.prokka%in%genomes)%>%select(group)%>%as.matrix()
    curr_phylo<-table(curr_group)
    phylo_cols<-match(names(curr_phylo),colnames(phylo_mat))
    phylo_mat[count,phylo_cols]<-curr_phylo
  }
  curr_df<-as.data.frame(phylo_mat,row.names = FALSE)%>%mutate(.,treatment=c("slow growth","fast growth"),cluster=curr_clust)%>%select(cluster,treatment,everything())
  
  sub.clust_phylo_df<-rbind(sub.clust_phylo_df,curr_df)
  
}



compare_df<-sub.clust_phylo_df %>% select(-c(Other)) %>% pivot_longer(-c(treatment,cluster),
                                                            names_to = "Group", values_to = "Number of Genomes") %>%
  group_by(treatment)

compare_df <- compare_df %>% group_by(cluster) %>% mutate(perc = `Number of Genomes`/sum(`Number of Genomes`))

#Now we want to compute the ratio between the within cluster abundances and full data abundances
compare_df$diff<-0
for (i in 1:length(fulldata_abundances$Order)){
  compare_df<-compare_df%>%mutate(diff=ifelse(Group==fulldata_abundances$Order[i],(perc/fulldata_abundances$Abundance[i])-1,diff))
}

#I need to make it so there is one set of taxonomic levels so the taxonomy colors are consistent
# order_df <- compare_df %>% group_by(Group) %>% summarise(mean = mean(perc)) %>%
#   arrange(mean)

compare_df$Group <- factor(compare_df$Group, levels = order_df$Order)
compare_df$cluster<-as.factor(compare_df$cluster)

#I'm also constructing two separate variables suitable to put the fraction of genomes in the low/high group as the plot title on facets
label_df<-compare_df%>%group_by(cluster,treatment)%>%summarise(total=sum(`Number of Genomes`))%>%group_by(cluster)%>%reframe(treatment=treatment,frac=total/sum(total))

slow_grow_labels<-paste("cluster",c(1:8),"proportion:",label_df%>%filter(treatment=="slow growth")%>%select(frac)%>%as.matrix()%>%round(.,digits=3)%>%as.character())
names(slow_grow_labels)<-levels(compare_df$cluster)

fast_grow_labels<-paste("cluster",c(1:8),"proportion:",label_df%>%filter(treatment=="fast growth")%>%select(frac)%>%as.matrix()%>%round(.,digits=3)%>%as.character())
names(fast_grow_labels)<-levels(compare_df$cluster)

#Plot facets for high versus low for all clusters
# ggplot(compare_df, aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "", y = "Proportion")+
#   facet_wrap(~cluster,nrow=4,ncol=2)+
#   theme(panel.spacing=unit(1,"lines"))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 


#Rather than above, let's do two distinct plots of all the high and low groups from each cluster separately
# cluster.slow_phylo_plot<-ggplot(filter(compare_df,treatment=="slow growth"), aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + 
#   facet_wrap(~cluster,nrow=4,labeller=labeller(cluster=slow_grow_labels))+
#   labs(title="Slow Growers",x = "", y = "Proportion")+
#   theme_bw()+
#   theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 
# 
# cluster.fast_phylo_plot<-ggplot(filter(compare_df,treatment=="fast growth"), aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + 
#   facet_wrap(~cluster,nrow=4,labeller=labeller(cluster=fast_grow_labels))+
#   labs(title="Fast Growers",x = "", y = "Proportion")+
#   theme_bw()+
#   theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 

#Plot the new version of the relative abundance charts
compare_df$cluster<-factor(compare_df$cluster,labels=paste("Cluster",c(1:num_clusters)))

cluster.phylo_plot<-ggplot(compare_df, aes(x = as.factor(treatment), y = perc, fill = Group)) +
  geom_bar(width=0.5,stat="identity") + coord_cartesian(expand = TRUE)+
  facet_wrap(~cluster,nrow=2)+
  labs(title="Fast Growers",x = "", y = "Proportion")+
  theme_bw()+
  theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b"),limits=force) 

#Now aggregate into just high and just low over all clusters and plot
mean.compare_df<-compare_df%>%select(-c(cluster))%>%group_by(treatment,Group)%>%summarise(mean_perc=mean(perc))

all.growth_phylo_plot<-ggplot(mean.compare_df,aes(x=as.factor(treatment),y=mean_perc,fill=Group))+geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "", y = "Proportion")+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b"),limits=force) 
  

#I would also like to integrate the scaled fluxes from the SOMs with phylogeny to see if there are consistent patterns within the phylogenetic groupings either across the SOMs or within a SOM cluster
match_genomes<-match(split_phylo_hq$Genome.prokka,gridpoint_df$value)
flux_df<-split_phylo_hq%>%mutate(grid=gridpoint_df$gridpoints[match_genomes],cluster=cluster_df$clusters[match_genomes])

#Remake classifiers dataframe
df <- carve.som$prototypes %>% as.data.frame()
classifiers_df<-data.frame(nodes=rownames(df))
for (i in 1:length(unique(class_df$Higher.Level.Classification))){
  curr_class<-unique(class_df$Higher.Level.Classification)[i]
  metab_indices<-which(class_df$Higher.Level.Classification %in% curr_class)
  metab_matches<-match(class_df$Metabolite[metab_indices],colnames(df))
  metab_matches<-metab_matches[which(colSums(df[,metab_matches])!=0)]
  if (length(metab_matches)>1){
    classifiers_df<-mutate(classifiers_df,!!curr_class:=rowMeans(df[,metab_matches]))
  } else {
    classifiers_df<-mutate(classifiers_df,!!curr_class:=mean(df[,metab_matches]))
  }
}

classifiers_df$cluster <- carve.sc$cluster

classifiers_df$row_names <- rep(1:gridcols,times = gridrows)
classifiers_df$column_names <- rep(1:gridrows,each = gridcols)

classifiers_df<-classifiers_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

#Now compute a *weighed* mean using the gridpoints each taxa is in to get average scaled fluxes by taxa
phylo_flux<-c()
for (i in 1:length(unique(split_phylo_hq$group))){
  curr_group<-unique(split_phylo_hq$group)[i]
  filter_df<-flux_df%>%filter(.,group==curr_group)
  node_weights<-table(filter_df$grid); curr_nodes<-names(node_weights)%>%as.numeric()
  weighted_means<-colSums(node_weights*classifiers_df[curr_nodes,5:17])/sum(node_weights)
  
  phylo_flux<-rbind(phylo_flux,weighted_means)
}
new_flux_df<-as.data.frame(phylo_flux); colnames(new_flux_df)<-colnames(classifiers_df)[5:17]
new_flux_df<-new_flux_df%>%mutate(taxa=unique(split_phylo_hq$group),nodes=c(1:length(unique(split_phylo_hq$group))))

new_flux_df$taxa<-factor(new_flux_df$taxa, levels = order_df$Order)

pivot_flux_df<-new_flux_df%>%pivot_longer(-c(taxa,nodes),names_to="Metabolite Class",values_to="Weighted Mean")

#Plot command to get bar charts, would like to add error lines. We will plot this two ways, grouped by metabolite class and grouped by taxa
#First we will group by metabolite class and facet wrap by taxa
metab.by.phylo_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = pivot_flux_df, aes(y = `Weighted Mean`, x = as.factor(`Metabolite Class`), fill = as.factor(`Metabolite Class`)),
           stat = "identity") +
  # geom_errorbar(data = metab_df, aes(x = cluster,ymin = means-sds, ymax = means+sds),
  #               width = 0.2) +
  facet_wrap(~`taxa`, ncol = 5, scales = "free_y") +
  labs(x = "", y= "Scaled Flux", fill = "Taxonomic Order") +
  scale_fill_manual(values = c("#7663cf",
                               "#8db43b",
                               "#c851b1",
                               "#55bc63",
                               "#d54767",
                               "#4fbeae",
                               "#d15236",
                               "#588dcc",
                               "#d2a23a",
                               "#a879bf",
                               "#458149",
                               "#bd6484",
                               "#89883f",
                               "#ba7648")) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size =12),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(0.95,0.05),
        legend.justification = c(1,0),
        axis.text.x=element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, ncol=3))

#Now plot with the taxa grouped and facet wrap by metabolite class
phylo.by.metab_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = pivot_flux_df, aes(y = `Weighted Mean`, x = as.factor(nodes), fill = taxa),
           stat = "identity") +
  # geom_errorbar(data = metab_df, aes(x = cluster,ymin = means-sds, ymax = means+sds),
  #               width = 0.2) +
  facet_wrap(~`Metabolite Class`, ncol = 3, scales = "free_y") +
  labs(x = "", y= "Scaled Flux", fill = "Taxonomic Order") +
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b")) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size =12),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(0.95,0.05),
        legend.justification = c(1,0),
        axis.text.x=element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 4))

#Code to create growth plots of sub clusters
tmp_df<-growth_df%>%mutate(growth=case_when(dCUB < curr_mean ~ "fast", dCUB >= curr_mean ~ "slow", TRUE ~ "NA"))%>%filter(growth!="NA")

tmp_df$group<-factor(tmp_df$group,levels=c(1:4))

#Plot it
subcluster.growth_plot<-ggplot(tmp_df,aes(x=growth,y=dCUB,color=group))+
  facet_wrap(~clusters,nrow=2,ncol=4)+
  geom_violin(width=1)+
  stat_summary(fun="mean",geom="crossbar",color="black")+
  scale_color_discrete(name="Group",labels=unique(Tukey.labels[,1]),drop=FALSE,limits=force)+
  labs(x="Group",color="Cluster")+
  geom_point()+
  ggtitle("Sub-grouped dCUB values for SOM clusters")+
  theme_bw()+
  theme(plot.title=element_text(hjust=0.5))


```

### Comparison to Matti's data... done!

```{r Matti Models, echo=FALSE}
load("Data/all_carve-som-info_double-scale-hq.RData")
clusters<-carve.sc$cluster
ids<-carve.sc$som$clustering
sample_clusters<-clusters[ids]

matti_fluxes<-read.csv("Data/matti_all_max_flux_filledNaNs_transposed.csv")%>%.[,-1]%>%as.matrix()
matti_headers<-read.csv("Data/matti_all_max_flux_headers_transposed.csv")
matti_dictionary<-read.csv("Data/matti_all_max_flux_met_names.csv")
rownames(matti_fluxes)<-as.matrix(matti_headers$model_name)
colnames(matti_fluxes)<-matti_dictionary$X0

matti_genomes<-unique(matti_headers$model_name)

zerocols<-which(colSums(matti_fluxes)==0)
if (is_empty(zerocols)==FALSE){
  matti_fluxes<-matti_fluxes[,-zerocols]
}
scaled_matti_fluxes<-scale(matti_fluxes)

remove_metab<-which(colnames(scaled_matti_fluxes) %in% c("Manganese","Zinc","Co2+","Calcium","Chloride","Potassium","Copper","Cu+","Magnesium","O2 O2"))
scaled_matti_fluxes<-scaled_matti_fluxes[,-remove_metab]; matti_fluxes<-matti_fluxes[,-remove_metab]

indices<-match(colnames(scaled_matti_fluxes),colnames(carve.som$prototypes))

match_fluxes<-carve.som$prototypes[,indices]

averaged_fluxes<-c()
for (i in matti_genomes){
  curr_rows<-which(matti_headers$model_name==i)
  averaged_fluxes<-rbind(averaged_fluxes,colMeans(scaled_matti_fluxes[curr_rows,]))
}

placed_points<-c()
placed_cluster<-c()
for (i in 1:dim(averaged_fluxes)[1]){
  curr_fluxes<-averaged_fluxes[i,]
  curr_dists<-dist(rbind(curr_fluxes,match_fluxes))[1:100]
  placed_point<-which(curr_dists==min(curr_dists))
  placed_points<-c(placed_points,placed_point)
  placed_cluster<-c(placed_cluster,clusters[placed_point])
}

sugar.acid.pref<-read_csv("Data/matti_sugar-acid-preference.csv")

metab_dependence<-read.csv("Data/met_depend_factor_by_genome_all_microbiomics.csv")
all_deps<-as.data.frame(metab_dependence$X)
for (i in 1:num_clusters){
  curr_clust<-paste("Cluster",i)
  curr_genomes<-cluster_df%>%filter(clusters==i)%>%select(value)
  match_genomes<-match(as.matrix(curr_genomes),colnames(metab_dependence))
  curr_deps<-metab_dependence[,match_genomes]%>%rowMeans(.)
  all_deps<-all_deps%>%mutate(!!curr_clust:=curr_deps)
}
all_deps<-as.data.frame(t(all_deps[,-1])); colnames(all_deps)<-metab_dependence$X
all_deps<-all_deps%>%mutate(cluster=c(1:num_clusters),`Carb/Acid Ratio`=(`Carbohydrates/Derivatives`/`Carboxylic Acid`)-1)%>%select(cluster,everything())

genome_df<-as.data.frame(unique(matti_headers$model_name))
colnames(genome_df)<-"Genome"
genome_df$cluster<-placed_cluster
match_genomes<-match(unique(matti_headers$model_name),sugar.acid.pref$...1)
genome_loc<-which(is.na(match_genomes)==FALSE)
genome_df$preference<-NA ; genome_df$preference[genome_loc]<-sugar.acid.pref$`sugar-acid preference`[match_genomes[genome_loc]]

sugar.acid.pref_plot<-ggplot()+
  geom_violin(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=1)+
  geom_boxplot(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=0.25)+
  scale_y_continuous(sec.axis=sec_axis(trans=~.*1,name="Metabolite Preference"))+
  geom_jitter(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=0.05)+labs(x="Cluster",y="Sugar-Acid Preference")+
  geom_jitter(data=all_deps%>%select(cluster,`Carboxylic Acid`,`Carbohydrates/Derivatives`,`Carb/Acid Ratio`)%>%pivot_longer(-cluster),aes(x=as.factor(cluster),y=value,color=name),size=3,alpha=0.75,width=0.1)+
  scale_color_manual(values=c("#656cc5",
                              "#6ab64c",
                              "#a15acb",
                              "#c2a741",
                              "#cb4798",
                              "#4eb596",
                              "#d24150",
                              "#5e9bd4",
                              "#d3612b",
                              "#c483c5",
                              "#677e39",
                              "#ba5e73",
                              "#bd794d"))+
  labs(color="Metab Class Preference")+
  theme_bw()+ theme(text=element_text(size=15))+
  geom_hline(yintercept=0,linetype=2)

filter_df<-genome_df%>%filter(preference!="NA"); filter_df$preference<-as.numeric(filter_df$preference)
# filter_df
# ggplot()+
#   geom_point(filter_df,aes())

cluster_medians<-filter_df%>%group_by(cluster)%>%summarise(median=median(preference))
#median_df<-cluster_medians%>%mutate(`Carboxylic Acid`=all_deps$`Carboxylic Acid`,`Carbohydrates`=all_deps$`Carbohydrates/Derivatives`)
median_df<-list(cluster_medians,all_deps)%>%reduce(full_join,by="cluster")%>%pivot_longer(-c(cluster,median),names_to="Metabolite Class",values_to="Metabolite Preference")
som_by_sugar.acid_plot<-ggplot()+
  geom_point(data=median_df,aes(x=median,y=`Metabolite Preference`,color=`Metabolite Class`))+
  labs(x="Median Sugar-Acid Preference",color="Cluster")+
  theme_bw()
  # +facet_wrap(~cluster,nrow=3,ncol=3)

#We also want to try to directly compare the predictions by CarveMe on matti's models to his experimentally validated growth rates on substrates
raw_growth_file<-read.csv("Data/Matti_growth-measurements.csv")
cols<-colnames(raw_growth_file)

#Manually slicing dataset for now but could use cols var + keywords
sugar_growth_info<-raw_growth_file[,c(11:38)]; colnames(sugar_growth_info)<-sugar_growth_info[1,]
sugar_growth_info<-sugar_growth_info[-1,]
acid_growth_info<-raw_growth_file[,c(39:49)]
colnames(acid_growth_info)<-acid_growth_info[1,]
acid_growth_info<-acid_growth_info[-1,]

#Compute the mean growth rate per genome on acids/sugars
sugar_means<-c()
for (i in 1:dim(sugar_growth_info)[1]){
  positive_growths<-which(sugar_growth_info[i,]>0)
  if (length(positive_growths)>1){
  curr_mean<-sugar_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()%>%mean()
  } else if (is_empty(positive_growths)==TRUE) {
    curr_mean<-0
  } else {
    curr_mean<-sugar_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()
  }
  sugar_means<-c(sugar_means,curr_mean)
}

acid_means<-c()
for (i in 1:dim(acid_growth_info)[1]){
  positive_growths<-which(acid_growth_info[i,]>0)
  if (length(positive_growths)>1){
  curr_mean<-acid_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()%>%mean()
  } else if (is_empty(positive_growths)==TRUE) {
    curr_mean<-0
  } else {
    curr_mean<-acid_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()
  }
  acid_means<-c(acid_means,curr_mean)
}
growth_means<-rowMeans(cbind(sugar_means,acid_means))

#Constructing a data frame with the genomes that were placed in SOMs and had non-NA sugar-acid preferences with their mean growth rates
mean.growth_df<-genome_df%>%filter(.,preference!="NA")%>%select(Genome)%>%mutate(`mean growth`=(match(Genome,raw_growth_file$X)-1)%>%growth_means[.])
mean.growth_df<-mean.growth_df%>%mutate(cluster=genome_df%>%filter(.,preference!="NA")%>%select(cluster)%>%as.matrix()%>%as.numeric())
colnames(mean.growth_df)[3]<-"cluster"

mean.growth_df<-mean.growth_df%>%group_by(.,cluster)%>%mutate(norm=`mean growth`/max(`mean growth`)*-1)
#Plot Matti's growth rates by cluster against the whole dataset growth rates by cluster
matti_growth_plot<-ggplot()+
  geom_violin(data=growth_df,aes(x=as.factor(clusters),y=dCUB),width=1)+
  stat_summary(data=growth_df,mapping=aes(x=as.factor(clusters),y=dCUB),fun="mean",geom="crossbar",color="blue")+
  geom_point(data=growth_df,aes(x=as.factor(clusters),y=dCUB))+
  geom_jitter(data=mean.growth_df,aes(x=as.factor(cluster),y=norm,color="red"),width=0.1,size=4,shape=18)+
  stat_summary(data=mean.growth_df,mapping=aes(x=as.factor(cluster),y=norm),fun="mean",geom="crossbar",color="red")+
  labs(color="Avg Growth",y="Cluster")+
  scale_colour_discrete(labels=c("Sugars+Acids"))+
  theme_bw()

#Pulling the names of the sugars then acids indivdiually to try to do per metabolite comparisons
data_sugars<-class_file%>%filter(.,Higher.Level.Classification=="Carbohydrates/Derivatives")%>%select(Metabolite)%>%as.matrix()
matti_sugars<-colnames(sugar_growth_info)

for (i in 1:length(matti_sugars)){
  matches<-grep(matti_sugars[i],data_sugars,ignore.case=TRUE)
  if (length(matches>2)){
    
  }
}


#We also want to look specifically at the metabolite dependences calculated on new CarveMe models run for Matti's genomes to match their experimental info to the CarveMe predicted info (mainly sugar/acid)
matti_dependencies<-read.csv(file="Data/matti_growth_dependance_new_annotations.csv",header=TRUE,row.names=1)%>%t()%>%as.data.frame()
rownames(matti_dependencies)<-rownames(matti_dependencies)%>%gsub("X","",.)

#Below code is in case the data is provided with the growth rates for each model as vectors in each index
# sub_df<-matti_dependencies%>%select(-c(som_cluster))
# for (i in 1:dim(sub_df)[1]){
#   for (j in 1:dim(sub_df)[2]){
#     sub_df[i,j]<-sub_df[i,j]%>%gsub('\\[|\\]','',.)%>%noquote()%>%strsplit(.,",")%>%unlist()%>%as.numeric()%>%mean()
#   }
# }

#Convert the growth rates into requirement values and reformat dataframe
# req_df<-sub_df
req_df<-matti_dependencies
# for (col in 1:dim(req_df)[2]){
#   req_df[,col]<-2*(1-(as.numeric(req_df[,col])/as.numeric(req_df[,1])))
# }

req_df<-req_df%>%mutate(genome=rownames(req_df))%>%select(genome,everything())
rownames(req_df)<-c()

#Add in the sugar/acid identifier to partition data
prefs<-sugar.acid.pref$`sugar-acid preference`[-1]%>%as.numeric()
binary_prefs<-vector(length=length(prefs))
binary_prefs[which(prefs>0)]<-"sugar_pref"; binary_prefs[which(prefs<0)]<-"acid_pref"

match_genomes<-match(raw_growth_file$X[-1],req_df$genome)
indices<-which(is.na(match_genomes)==FALSE)

req_df<-req_df%>%mutate(preference="unmeasured",.before=`Carboxylic Acid`)
req_df$preference[match_genomes[indices]]<-binary_prefs[indices]

#Now plot the metabolite dependence values grouped by whether they are sugar or acid preferring oragnisms and their SOM cluster
matti.grow_df<-req_df%>%select(-c(genome,preference))%>%t()%>%as.data.frame()%>%mutate(metabolite_class=rownames(.),.before=everything())
rownames(matti.grow_df)<-NULL; colnames(matti.grow_df)[-1]<-req_df$genome

matti.grow_df <- matti.grow_df %>% pivot_longer(-metabolite_class, names_to = "genome",values_to = "growth_req") %>%
  filter(metabolite_class != "Inorganic")

# matti.grow_df$cluster <- req_df$cluster[match(matti.grow_df$genome,req_df$genome)]
matti.grow_df$preference<-req_df$preference[match(matti.grow_df$genome,req_df$genome)]

#Plot the density ridges for specific metabolite classes for all the dependence values of Matti's genomes
sub.matti.grow_df<-matti.grow_df%>%filter(metabolite_class%in%c("Amino Acids/Derivatives","Carbohydrates/Derivatives","Carboxylic Acid","Nucleobases/Nucleosides/Nucleotides/Derivatives"))

matti.all.deps.density<-ggplot(data=sub.matti.grow_df,aes(x=growth_req,y=preference,fill=preference))+geom_density_ridges(scale=0.9)+facet_wrap(~metabolite_class)+theme(legend.position="none")

matti.sum_grow <- matti.grow_df %>% group_by(preference,metabolite_class) %>%
  summarise(avg_grow_req = mean(growth_req, na.rm = TRUE)) 

matti.grow_order <- matti.grow_df %>% group_by(metabolite_class) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

#matti.sum_grow$cluster <- factor(matti.sum_grow$cluster)
matti.sum_grow$preference<-factor(matti.sum_grow$preference)
matti.sum_grow$metabolite_class <- factor(matti.sum_grow$metabolite_class, levels = matti.grow_order$metabolite_class[c(4,1:3,5:12)])

matti.sum_grow <- matti.sum_grow %>% group_by(metabolite_class) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req)))) 


matti_growth_dep_plot <- ggplot(matti.sum_grow, aes(x = preference, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(guide = "none", range = c(2,10)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black")) +
  labs(x = "Cluster", fill = "Average Growth Requirement")

#Try also looking at the growth rate values compared to the metabolite dependence factors
#Identify which metabolites are present in our set of classified metabolites
match_acids<-c()
for (i in 1:length(colnames(acid_growth_info))){
  curr_search<-colnames(acid_growth_info)[i]
  matches<-grep(curr_search,class_df$Metabolite,ignore.case=TRUE)
  if (is_empty(matches)==TRUE){
    print(paste("Metabolite",curr_search,"has no matches!"))
    next
  }
  match_acids<-rbind(match_acids,as.matrix(class_df[matches,]))
}

match_sugars<-c()
for (i in 1:length(colnames(sugar_growth_info))){
  curr_search<-colnames(sugar_growth_info)[i]
  matches<-grep(curr_search,class_df$Metabolite,ignore.case=TRUE)
  if (is_empty(matches)==TRUE){
    print(paste("Metabolite",curr_search,"has no matches!"))
    next
  }
  match_sugars<-rbind(match_sugars,as.matrix(class_df[matches,]))
}


```

### Read recruitment analysis... done!

```{r Read Recruitment, echo=FALSE}
rpkm_vals <- read.csv("Data/carve_me_rpkm_1425.csv")
meta <- read.csv("Data/Estuary_metadata - Celeste_Paper.csv")
som <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(som)<-c("value","clusters")
som$value <- paste0(som$value,"-prokka-original")

colnames(rpkm_vals)[1] <- "Genome"

rpkm_vals <- rpkm_vals %>% pivot_longer(-Genome, names_to = "Sample", values_to = "rpkm")

per_samp_rpkm <- rpkm_vals %>% group_by(Sample) %>%
  summarise(sum_rpkm = sum(rpkm,na.rm = TRUE))

rpkm_vals$cluster <- som$clusters[match(rpkm_vals$Genome,som$value)]

som_rpkm <- rpkm_vals %>% filter(!is.na(cluster)) %>% group_by(cluster, Sample) %>%
  summarise(sum_rpkm = sum(rpkm,na.rm = TRUE)) %>% ungroup() %>%
  group_by(Sample) %>%
  mutate(rel_rpkm = sum_rpkm/sum(sum_rpkm,na.rm=TRUE))

som_rpkm$cluster <- factor(som_rpkm$cluster)

plot_df = som_rpkm %>%
  nest(data=-Sample) %>%
  mutate(plot = map2(data, Sample,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = "", y = rel_rpkm, fill = cluster) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1, alpha = 0.7) +
                       coord_polar("y")))

plot_df$total_rpkm <- per_samp_rpkm$sum_rpkm[match(plot_df$Sample,per_samp_rpkm$Sample)]
plot_df$lat <- meta$lat[match(plot_df$Sample, meta$sra_acc)]
plot_df$long <- meta$lon[match(plot_df$Sample, meta$sra_acc)]
plot_df$Region <- meta$Region[match(plot_df$Sample, meta$sra_acc)]

plot_df$lat[which(plot_df$lat == -3645)] <- 36.45 # See if this is the issue

plot_df <- plot_df %>% filter(!is.na(lat))

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(long, lat, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-5, xmax = ..1+5,
                                               ymin = ..2-5, ymax = ..2+5))) %>%
  pull(annotation)


map <- map_data("world")

all_recruitment_plot <- ggplot() + 
  geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
  plot_annotations +
  coord_cartesian(expand = 0) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
        axis.title = element_text(size = 15),
        axis.text = element_text(size = 15)) + 
  labs(x = "Longitude", y = "Latitude")

som_rpkm$total_rpkm <- per_samp_rpkm$sum_rpkm[match(som_rpkm$Sample,per_samp_rpkm$Sample)]
som_rpkm$lat <- meta$lat[match(som_rpkm$Sample, meta$sra_acc)]
som_rpkm$long <- meta$lon[match(som_rpkm$Sample, meta$sra_acc)]
som_rpkm$Region <- meta$Region[match(som_rpkm$Sample, meta$sra_acc)]

som_rpkm$lat[which(som_rpkm$lat == -3645)] <- 36.45 # See if this is the issue

per_clust_map_plot<-ggplot() +
  geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
  geom_point(data = som_rpkm, aes(x = long, y = lat, size = sum_rpkm, color = rel_rpkm), alpha = 0.7) +
  coord_cartesian(expand = 0) + facet_wrap(~cluster) +
  scale_color_viridis_c(labels = scales::percent_format()) +
  labs(x = "Longitude", y = "Latitude", size = "Total RPKM", color = "Relative Abundance") +
  theme(plot.title=element_text(hjust=0.5),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 12),
        axis.text = element_text(size =12),
        axis.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.key = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(1,0),
        legend.justification = c(1,0)) +
  guides(color = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(2, "in")),
         size = guide_legend(title.position = "top", title.hjust = 0.5))

```


## 3    Results

#### 3.1    Data phylogeny and model consensus

#### Figure 1: Phylogenetic Tree of Dataset. The first external ring shows the position of genomes belonging to the top 15 most abundant taxonomic orders. The second external ring shows the location of the reference genoms on which CarveMe was developed in red. The third external ring shows the consensus value for the CarveMe ensemble generated for each genome, while the final external ring shows the position of genomes belonging to each of the 8 SOM clusters for genomes that passed our consensus threshold.

```{r Tree plot, echo=FALSE, fig.width=12, fig.height=12}

plot(out_tree4)

```

### 3.2   CarveMe Validation

#### Supplemental Figure XX: Bubble plot of average growth dependency for genomes from xx Matti dataset xx grouped by their experimentally verified metabolic preference towards acids or sugars.

```{r Matti Growth Dependency Plot, echo=FALSE}

plot(matti_growth_dep_plot)

```

<!-- #### Other Model validation Supplemental Figures: -->

<!-- ```{r Other Matti Data Plots, echo=FALSE} -->

<!-- plot(sugar.acid.pref_plot) -->

<!-- plot(som_by_sugar.acid_plot) -->

<!-- plot(matti_growth_plot) -->

<!-- ``` -->

### 3.3   SOM clustering

### 3.3.1   dCUB growth estimates

#### Figure 2: Violin plots of growth estimates (approximated by dCUB) for SOM clusters.

```{r Growth plot, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Distribution of dCUB values for each cluster with mean lines charted in blue.")
plot(growth_violin_plot)

print("Figure: Average scaled flux and average dCUB value per cluster colored by statistically different groups by growth.")
plot(flux_versus_growth_plot)

print("Figure: Example of sub-clustering based on dCUB values")
plot(subcluster.growth_plot)

```

### 3.3.2 Metabolic profiles


#### Figure 3: Visualization of SOM map with individual grid point densities and xx color...

```{r SOM grid, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: SOM grid grouped by cluster (squares), colored by dCUB, and sized based on number of genomes associated with each grid point.")
plot(som_grid_plot)

print("Distribution of total raw fluxes by cluster")
plot(raw.flux_plot)

print("Figure: Per grid point relative abundances of metabolite classes")
plot(grid_plot)

print("Figure: Scaled SOM prototype flux values per cluster (with 1 sd error bars) for each metabolite class.")
plot(cluster_plot)
  
print("Figure: Similar bubble plot to previous plot for growth limitation. Colors describe the information presented in above figure of the scaled SOM prototype fluxes while bubble sizes describe the relative importance of each metabolite class between clusters.")
plot(flux_bubble_plot)


print("Figure: Per cluster relative abundances of metabolite classes.")
plot(flux_abund_plot)

print("Figure: Metabolite class enrichments grouped by taxonomic order")
plot(metab.by.phylo_plot)

print("Figure: Metabolite class enrichments for taxonomic orders grouped by metabolite class.")
plot(phylo.by.metab_plot)

```

### 3.3.3   Cluster phylogeny

```{r Phylogeny plots, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Within cluster relative abundances of top 15 phylogenetic orders (in total dataset) plus 'Other' category.")
plot(phylo_abund_plot)

print("Figure: Per cluster relative abundances of top 15 orders (in total dataset) grouped by order.")
plot(phylo_stacked_abund_plot)

print("Figure: Relative difference between within cluster and full dataset abundance of top 15 taxonomic orders grouped by order.")
plot(phylo_rel_diff_plot)

print("Figure: Relative abundances of top 15 orders for genomes in all fast and slow growth subclusters")
plot(all.growth_phylo_plot)

# print("Figure: Relative abundance of top 15 orders for each slow growing subcluster")
# plot(cluster.slow_phylo_plot)
# 
# print("Figure: Relative abundance of top 15 orders for each fast growing subcluster")
# plot(cluster.fast_phylo_plot)

print("Figure: Relative abundance of top 15 orders for the fast and slow growing subclusters")
plot(cluster.phylo_plot)

print("Figure: Bray-Curtis dissimilarity between the relative abundances of unique genuses in the dataset as cluster size is increased from 2 to 12 (NOTE: undefined genuses were defined as `order`_other).")
print(bray_plot)


```

### 3.3.4   Growth Dependency/Requirement

```{r Metabolite Growth Dependence, echo=FALSE, fig.width=12, fig.height=12}

plot(growth_dep_plot)

```

#### Alternative Figure 4: Different plots of the same data. First alternative version shows same information, except bubble sizes are the average scaled fluxes of each metabolite class for each cluster. The second alternative version instead groups the dependence data by the top 15 taxonomic orders and sorts them from the order with the highest total dependence to the lowest total dependence.

```{r Alternative Figure 4, echo=FALSE}

plot(growth_dep_flux.size_plot)

plot(growth_dep_by.phylo_plot)

```


#### Supplemental Figure XX: Potential growth limitation grouped by metabolite class. Sets of bars for each metabolite class are colored by SOM cluster.

```{r Growth Limitation Chart, echo=FALSE}

plot(out_grow)

```

```{r Metabolite Dependence vs Scaled Flux, echo=FALSE}

print("Figure: Plot of scaled SOM prototype fluxes versus potential growth limitation by cluster for each of the metabolite classes.")
plot(flux_versus_dep_plot)

```

### 3.4   Geographic Distribution

```{r Read recruitment, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Read recruitment map showing the relative abundance of RPKM attributed to each cluster at each station.")
plot(all_recruitment_plot)

print("Figure: Per cluster read recruitment maps colored by relative contribution to total RPKM at each station. Bubble sizes reflect total RPKM value at each site.")
plot(per_clust_map_plot)

```

### Supplemental Figures

#### S1   SOM metrics

```{r SOM metrics, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Traditional PCA of data colored by SOM clusters")
plot(pca_plot)

print("Figure: Scaled mean flux values for metabolites with >10% flux relative to mean colored by cluter")
plot(mean_flux_clust_plot)

print("Figure: Scaled mean flux versus scaled mean standard deviation for metabolites with >10% flux relative to mean colored by cluster")
plot(mean_versus_std_flux_plot)

print("Figure: Distribution of coefficients of variance for each genome ensemble based on non-zero metabolite flux values for all ensemble models")
plot(coeffs_var_plot)

print("Figure: Distribution of counts of models in each cluster per genome.")
plot(evenness_plot)

print("Figure: Custom defined breadth, consensus, and evenness metrics for the distribution of each genome ensemble's models across clusters")
plot(SOM_metrics_plot)

```

#### S2   Read recruitment

