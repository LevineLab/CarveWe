---
title: "Kohonen-based SOM clustering directly on growth sensitivity data (high-quality data subset)"
output: html_document
date: "2023-08-04"
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../Output",
      output_file= "CarveMe_growth-data-kohonen-SOM.html"
    )
  })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.height=12, fig.width=12)
knitr::opts_knit$set(root.dir="/Users/Ryan/Documents/Levine_Lab/R_Studio/CarveWe")
#Load in packages
library(SOMbrero)
library(gplots)
library(tidyverse)
library(patchwork)
library(purrr)
library(ragg)
library(ggtree)
library(treeio)
library(ggnewscale)
library(vegan)
library(multcompView)
library(ggridges)
library(kohonen)
#Set a random seed
set.seed(123)
#Make/call functions

#We need to do some bootstrapping analysis per a request from Cameron. I think what we need to do is bootstrap the genomes in each cluster and then compute sums and relative abundances -> get a CI on relative abundance per cluster per region -> using functions from Ben Temperton
bootstrap_sum_pi<-function(data, func, size=1000){
  bs_sample = sample(data, size=size, replace=TRUE)
  do.call(func, list(x=bs_sample))
}

generate_bootstrap_replicates<-function(data, func, n=1000, size=1000){
  replicate(n, do.call(bootstrap_sum_pi, list(data=data, func=func, size=size)))
}

```

## Data Setup

```{r reading data, echo=FALSE,include=FALSE}
#We will attempt to pre-merge the metabolites by metabolite class to see how this impacts SOMs and results
class_file<-read.csv("Data/classified_metabolites.csv")

#Try pre-filtering out Inorganics as well since they dominate the total flux by fraction
class_file<-class_file%>%distinct(Metabolite,.keep_all=TRUE)%>%filter(!Higher.Level.Classification%in%c("Other","Inorganic"))

#Load in the necessary data files and reformat as necessary
metabolite_dictionary<-read.csv("./Data/all_max_flux_met_names_diamond.csv")
metabolite_info<-read.csv("Data/all_max_flux_diamond_transposed.csv")
file_headers<-read.csv("Data/all_max_flux_headers_diamond.csv")

load(file="data/new-growth50-test-data_all-cats.Rdata")

#Fix some string display issues with metabolite class names
remove_classes<-unique(all_dat$X)[-12]; metab_classes<-unique(all_dat$metab_class)[-c(7,8,12)]

match_rows<-match(all_dat$metab_class,metab_classes,nomatch=NA)

all_dat<-all_dat%>%mutate(X=case_when(X%in%remove_classes ~ metab_classes[match(X,remove_classes)],!X%in%remove_classes ~ X))

#Now we will separate out the original fluxes and add them to the dataframe so we can then compute differences
original_dat<-filter(all_dat,X=="original_media")
adjusted_dat<-filter(all_dat,X!="original_media")

#For the version where we reduced the flux of metabolite classes to 0 there are some models with no growth so we should exclude those
nogrow_dat<-adjusted_dat%>%filter(metab_class=="Growth"&averaged_flux<=10^-6)%>%reframe(ids=unique(paste(X,genome,model)))%>%as.matrix()
adjusted_dat<-adjusted_dat%>%mutate(key=paste(X,genome,model))%>%filter(!key%in%nogrow_dat)%>%select(-key)

#This line would be to average by all the models but we have information per model so not necessary (or reflective maybe). Requires adjusting the following lines too
# adjusted_dat<-adjusted_dat%>%group_by(X,metab_class,genome)%>%summarise(averaged_flux=mean(averaged_flux))%>%arrange(genome)

adjusted_dat$orig_flux<-original_dat$averaged_flux[match(paste(adjusted_dat$genome,adjusted_dat$model,adjusted_dat$metab_class),paste(original_dat$genome,original_dat$model,original_dat$metab_class))]

#There are some genomes with no metabolites from certain metabolite classes so let's now remove any rows with NA for the orig_flux
adjusted_dat<-adjusted_dat%>%filter(!is.na(orig_flux))

#We are now filtering out the archaeal genomes from the dataset and will do that by loading a pre-determined list of the high quality bacterial genomes and filtering the data frame
load("Data/hq-bacterial-genomes.RData")
adjusted_dat<-adjusted_dat%>%filter(genome%in%bacterial.hq.genomes)

#We also want to make a growth corrected version of the data where we standardize the values by the differences in the original versus adjusted data
growth_correction<-adjusted_dat%>%filter(metab_class=="Growth")%>%mutate(correction=orig_flux/averaged_flux)%>%select(X,genome,model,correction)
adjusted_dat$correction<-growth_correction$correction[match(paste(adjusted_dat$X,adjusted_dat$model,adjusted_dat$genome),paste(growth_correction$X,growth_correction$model,growth_correction$genome))]

all.grow_df<-adjusted_dat%>%filter(metab_class=="Growth")%>%group_by(genome,model,X)%>%
mutate(growth_req=case_when(averaged_flux/orig_flux<=1 ~ (2*(1-averaged_flux/orig_flux)),averaged_flux/orig_flux>1 ~ 0))%>%
  reframe(growth_req=mean(growth_req))
colnames(all.grow_df)<-c("genome","model","metabolite_class","growth_req")

all.grow_df<-all.grow_df%>%pivot_wider(names_from=metabolite_class,values_from=growth_req)

metabolite_matrix<-all.grow_df%>%select(-c(genome,model))%>%as.matrix()
rownames(metabolite_matrix)<-all.grow_df$genome%>%as.vector()

```

```{r Custom Themes and Colors, echo=FALSE, include=FALSE}

custom_theme<-theme(plot.title=element_text(hjust=0.5),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 16),
        axis.text = element_text(size =16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16),
        legend.key = element_blank())

# cluster_colors<-c("#bd5abe",
#                   "#70a845",
#                   "#746ec8",
#                   "#b69040",
#                   "#61a0d5",
#                   "#cc5a43",
#                   "#4aaa86",
#                   "#c55d86")
cluster_colors<-c("#243a56","#cd5b34","#4e7b94","#547e48","#a6a541","#60bb68","#5279ca","#86c1de")

phylo_colors<-c("#b8617c","#63b750","#895bc9","#b2b53b","#c84ca3","#3d854f","#d74164","#54bf9f","#cf5230","#54acd8","#d48e36","#5f7ac7","#6e772c","#bf83c9","#bca262")

```

## 2    Methods

# Running Code
## Running the SOM clustering procedure with our given parameters.


```{r Run SOMs}
#Code using kohonen package instead of sombrero
# gridsize=ceiling(dim(metabolite_matrix)[1]^(1/2.5))
gridsize=20
num_clusters=8

set.seed(123)
# som.grid<-somgrid(xdim=gridsize,ydim=gridsize,topo="hexagonal",toroidal=TRUE)
# som.model<-som(metabolite_matrix,grid=som.grid,rlen=1500,alpha=c(0.025,0.01))

load("Data/final-kohonen-som.RData")

#This has been an issue but we need to set the specific seed present *after* running the original SOM model to be able to reproduce the exact results
.Random.seed<-good.seed

#Plot the training progress to see and also to ensure right parameters were used
plot(som.model,type="changes")

carve.som<-som.model$codes[[1]]
som.dist <- as.matrix(dist(carve.som))

clusterMeanDist <- function(clusters){
  cluster.means = c()
  
  for(c in unique(clusters)){
    temp.members <- which(clusters == c)
    
    if(length(temp.members) > 1){
      temp.dist <- som.dist[temp.members,]
      temp.dist <- temp.dist[,temp.members]
      cluster.means <- append(cluster.means, mean(temp.dist))
    }else(cluster.means <- append(cluster.means,0))
  }
  
  return(mean(cluster.means))
  
}

try.k <- 2:20
cluster.dist.eval <- as.data.frame(matrix(ncol = 3, nrow = (length(try.k))))
colnames(cluster.dist.eval) <- c('k', 'kmeans', 'hclust')

for(i in 1:length(try.k)) {
  cluster.dist.eval[i, 'k'] <- try.k[i]
  cluster.dist.eval[i, 'kmeans'] <- clusterMeanDist(kmeans(carve.som, centers = try.k[i], iter.max = 20)$cluster)
  cluster.dist.eval[i, 'hclust'] <- clusterMeanDist(cutree(hclust(vegdist(carve.som,method="euclidean")), k = try.k[i]))
}

plot(cluster.dist.eval[, 'kmeans'] ~ try.k,
     type = 'l')

lines(cluster.dist.eval[, 'hclust'] ~ try.k,
      col = 'red')

legend('topright',
       legend = c('k-means', 'hierarchical'),
       col = c('black', 'red'),
       lty = c(1, 1))


cluster.tries <- list()

for(k in num_clusters){
  
  ## k-means clustering
  
  som.cluster.k <- kmeans(carve.som, centers = k, iter.max = 10000, nstart = 10)$cluster # k-means
  
  ## hierarchical clustering
  
  som.dist <- dist(carve.som) # hierarchical, step 1
  som.cluster.h <- cutree(hclust(som.dist), k = k) # hierarchical, step 2
  
  ## capture outputs
  
  cluster.tries[[paste0('som.cluster.k.', k)]] <- som.cluster.k
  cluster.tries[[paste0('som.cluster.h.', k)]] <- som.cluster.h
}

obs_density<-data.frame(node=som.model$unit.classif)%>%group_by(node)%>%summarise(count=n())

ggplot(obs_density,aes(x=count))+geom_histogram()+custom_theme

#Want to find the average variance and number of models represented in each cluster
clusters<-som.cluster.k
ids<-som.model$unit.classif
sample_clusters<-som.cluster.k[som.model$unit.classif]

na.nodes<-which(c(1:gridsize^2)%in%unique(obs_density$node)==FALSE)
som.cluster.k[na.nodes]<-NA

all_vars<-c()
for (i in 1:k){
  curr_clust=i
  
  curr_models<-which(clusters==curr_clust)
  
  if (length(curr_models)>1){
    curr_vars<-apply(metabolite_matrix[curr_models,],2,sd)%>%mean()
    all_vars<-c(all_vars,curr_vars)
  } else {
    all_vars<-c(all_vars,0)
  }
}

var_df<-data.frame(clust_size=table(sample_clusters),mean_var=all_vars)
colnames(var_df)<-c("cluster","num_models","mean_var")

# ggplot(var_df,aes(x=num_models,y=mean_var,color=cluster))+geom_point(size=5)+labs(color="Cluster",x="Number of models in cluster",y="Average variance in cluster")+scale_color_manual(values = c("#a0a052","#6c63d7","#a0b533","#c957ca","#5db855","#98459e","#d89d37","#7a93dd","#c9532a","#46aed7","#d6445a","#50b593","#d1438d","#4c7937","#c285de","#91682d","#625fa3","#dd8a68","#d883af","#a44d61"))

```

### SOM cluster analysis... done!

```{r SOM analysis, echo=FALSE}
#We also want to examine the recipes to find genomes where all or nearly all recipes are identical
genome_IDs<-unique(rownames(metabolite_matrix))
dupe_count<-0
dupe_IDs<-c()
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(metabolite_matrix) %in% curr_id)
  sub_mat<-metabolite_matrix[curr_indices,]
  dupe_check<-unique(sub_mat)
  if (dim(dupe_check)[1]==1){
    # print(paste("Dupe found in genome",curr_id))
    dupe_IDs<-cbind(dupe_IDs,curr_id)
    dupe_count<-dupe_count+1
  }
}
print(paste("There were",dupe_count,"genomes with duplicate growth sensitivity vectors across all models"))

#Determine the majority cluster to which each genome belongs
majority_clust<-c()
set.seed(123)
tracker<-0
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(metabolite_matrix) %in% curr_id)
  curr_clust<-sample_clusters[curr_indices]%>%table()
  
  major<-which(curr_clust %in% max(curr_clust)) %>% names(curr_clust)[.] %>% as.numeric()
  #There are a handful of models (14 in the current construction, 10x10 grid for the >50% genomes) that have two SOM clusters that tie for majority so we are randomly selecting in those cases
  if (length(major)==1){
    majority_clust<-c(majority_clust,major)
    tracker<-tracker+1
  } else {
    #Functionality to visualize the genomes with ties
    print(paste(curr_id,"has",length(major),"SOM clusters with",max(curr_clust),"models each."))
    #print(curr_clust)
    
    majority_clust<-c(majority_clust,sample(major,1))
  }
}
cluster_df<-as_tibble(genome_IDs)%>%mutate(.,clusters=majority_clust)

#We want to repeat this process for the majority SOM grid point which is more specific than SOM cluster
majority_gridpoint<-c()
set.seed(123)
for (i in 1:length(genome_IDs)){
  curr_id<-genome_IDs[i]
  curr_indices<-which(rownames(metabolite_matrix) %in% curr_id)
  curr_point<-ids[curr_indices]%>%table()
  
  major<-which(curr_point %in% max(curr_point)) %>% names(curr_point)[.] %>% as.numeric()
  #There are a handful of models (14 in the current construction, 10x10 grid for the >50% genomes) that have two SOM clusters that tie for majority so we are randomly selecting in those cases
  if (length(major)==1){
    majority_gridpoint<-c(majority_gridpoint,major)
  } else {
    #Functionality to visualize the genomes with ties
    print(paste(curr_id,"has",length(major),"SOM grid points with",max(curr_point),"models each."))
    #print(curr_clust)
    
    majority_gridpoint<-c(majority_gridpoint,sample(major,1))
  }
}
gridpoint_df<-as_tibble(genome_IDs)%>%mutate(.,gridpoints=majority_gridpoint)
gridpoint_table<-table(gridpoint_df$gridpoints)

data_pca<-prcomp(metabolite_matrix)
points<-data_pca$x%>%as_tibble()%>%mutate(.,clusters=sample_clusters)
points$clusters<-as_factor(points$clusters)

pca_plot<-ggplot(points,aes(x=PC1,y=PC2,colour=clusters))+
  geom_point()+
  theme_bw()+
  custom_theme+
  labs(x="PC1 (28.0%)",y="PC2 (22.6%)",color="SOM Cluster")+
  scale_color_manual(values=cluster_colors)+
  guides(color=guide_legend(override.aes=list(size=4.5)))

#Now try reformulating the dataframe by metabolite and look at summary stats
scaled_df<-as_tibble(metabolite_matrix)%>%mutate(.,clusters=sample_clusters,genomes=rownames(metabolite_matrix))%>%
  pivot_longer(-c(clusters,genomes),names_to="metab_class",values_to="scaled_value")
scaled_df$clusters<-as_factor(scaled_df$clusters)

summarize_df<-scaled_df%>%group_by(clusters,metab_class)%>%summarize(mean=mean(scaled_value,na.rm=TRUE),std=sd(scaled_value,na.rm=TRUE))

# ggplot(summarize_df,aes(x=metabolite,y=mean,colour=clusters))+geom_point()+theme_bw()

#Repeating the above process but thresholding out metabolites
threshold_df<-summarize_df%>%filter(abs(mean)>0.01)

mean_flux_clust_plot<-ggplot(threshold_df,aes(x=metab_class,y=mean,colour=clusters))+geom_point()+theme_bw()+theme(axis.text.x=element_blank())+ylab("Scaled Mean Flux")

mean_versus_std_flux_plot<-ggplot(threshold_df,aes(x=mean,y=std,colour=clusters))+geom_point()+theme_bw()+xlab("Scaled Mean Flux")+ylab("Scaled Standard Deviation")

#We want to compute several metrics on the data itself to determine need for thresholding and excluding certain metabolites

#First we want to look at the average coefficients of variance per metabolite per genome (one value per genome)
#Use the genome IDs to subset all models for a genome
genome_IDs<-unique(rownames(metabolite_matrix))
average_coeffsvar<-vector(mode="integer",length=length(genome_IDs))
for (i in 1:length(genome_IDs)){
  curr_rows<-which(rownames(metabolite_matrix)==genome_IDs[i])
  curr_matrix<-metabolite_matrix[curr_rows,]
  #Need to remove metabolites that aren't present in any recipes
  zerocols<-which(colSums(curr_matrix)==0)
  curr_matrix<-curr_matrix[,-zerocols]
  
  #Now compute the coefficient of variance (mean/sd), need to also exclude zeros here in each column
  curr_means<-apply(curr_matrix,2,function(v) v[which(v>0)]%>%mean())
  curr_sds<-apply(curr_matrix,2,function(v) v[which(v>0)]%>%sd())
  #Any NA values reflect metabolites with only one non-zero flux so we will modify those to 0
  curr_sds[which(is.na(curr_sds)==TRUE)]<-0
  
  coeffs_var<-curr_sds/curr_means
  average_coeffsvar[i]<-mean(coeffs_var)
}

#Convert to a dataframe and plot as a histogram
coeffs_df<-as_tibble(average_coeffsvar)

coeffs_var_plot<-ggplot(coeffs_df,aes(x=value))+geom_histogram(color="blue",fill="white")+labs(x="Average Coefficient of Variance",y="Number of Genomes")+theme_bw()

#We want to look at the evenness of model distribution across the clusters to look for genomes to remove
ids<-som.model$unit.classif
sample_clusters<-som.cluster.k[som.model$unit.classif]
counts_table<-vector(mode="integer",length=60)
largest_group<-c()
for (i in 1:length(genome_IDs)){
  curr_rows<-which(rownames(metabolite_matrix)==genome_IDs[i])
  curr_distr<-sample_clusters[curr_rows]%>%table()%>%unique()
  counts_table[curr_distr]<-counts_table[curr_distr]+1
  
  largest_group<-c(largest_group,sort(curr_distr,decreasing=TRUE)[1])
}
evenness_df<-as_tibble(counts_table)

evenness_plot<-ggplot(evenness_df,aes(x=c(1:60),y=value))+
  geom_point(size=4)+
  labs(x="Number of replicates in cluster",y="Number of Genomes")+
  theme_bw()+custom_theme

# #We also want to identify for different levels of K how much genome replicates are being split into multiple nodes
sizes<-c(2:20)
# genome_IDs<-unique(file_headers$model_name)
consensus<-matrix(data=0,nrow=length(sizes),ncol=1)
breadth<-matrix(data=0,nrow=length(sizes),ncol=1)
evenness<-matrix(data=0,nrow=length(sizes),ncol=1)
for (i in 1:length(sizes)){
  curr_size=sizes[i]
  curr.sc<-kmeans(carve.som, centers = curr_size, iter.max = 10000, nstart = 10)$cluster
clusters<-som.cluster.k
ids<-som.model$unit.classif
tmp_sample_clusters<-curr.sc[som.model$unit.classif]

  tmp.cons<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  tmp.breadth<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  tmp.evenness<-matrix(data=0,nrow=length(genome_IDs),ncol=1)
  for (j in 1:length(genome_IDs)){
    curr_genome<-genome_IDs[j]
    #curr.cons<-(which(file_headers$model_name %in% curr_genome)%>%sample_clusters[.]%>%table()%>%max())/60
    #curr.breadth<-(which(file_headers$model_name %in% curr_genome)%>%sample_clusters[.]%>%unique()%>%length())/60
    curr_cluster<-which(rownames(metabolite_matrix) %in% curr_genome)%>%tmp_sample_clusters[.]
    curr.cons<-(curr_cluster%>%table()%>%max())/60
    curr.breadth<-(curr_cluster%>%unique()%>%length())/60
    if (length(table(curr_cluster))==1){
      curr.evenness<-1
    } else {
      curr.evenness<-(max(table(curr_cluster))-min(table(curr_cluster)))/60
    }

    tmp.cons[j]<-curr.cons
    tmp.breadth[j]<-curr.breadth
    tmp.evenness[j]<-curr.evenness
  }
  consensus[i]<-mean(tmp.cons)
  breadth[i]<-mean(tmp.breadth)
  evenness[i]<-mean(tmp.evenness)
}
consensus_df<-cbind(sizes,consensus,breadth,evenness)%>%as.data.frame()
colnames(consensus_df)<-c("Cluster Size","Consensus","Breadth","Evenness")
consensus_df<-consensus_df%>%pivot_longer(-c(`Cluster Size`),names_to="Metric",values_to="Value")

SOM_metrics_plot<-ggplot(consensus_df,aes(x=`Cluster Size`,y=Value,color=Metric))+geom_line()+ylim(0,1)+theme_bw()+custom_theme


```

### Tree generation... done!
```{r Big Tree, echo=FALSE}
source("Codes/phylo_code.R")

# pull in data

# tree <- read.tree("Data/source-genomes-GToTree_Output.tre")
raw_tree <- read.iqtree("Data/bac-only-UFboot-tree.treefile")

#Make some modifications to the tree file here so we can look at bootstrap support, etc.
raw_tree<-raw_tree%>%mutate(support=case_when(UFboot>=95 ~ 1, UFboot<95 ~ 0, .default=1))
tree <- as.phylo(raw_tree)

uf_boot <- raw_tree@data$UFboot
support <- case_when(uf_boot>=95 ~ 1, uf_boot<95 ~ 0, .default=1)

tree$support <- support


phylo<-read.csv("Data/derep_all-GTDB-phylo_r214.tsv",sep="\t",header=TRUE)

#Load the phylogeny and remove the Archaea
split_phylo<-phylo%>%mutate(GTDB.Taxonomy=gsub("[a-z]__","",GTDB.Taxonomy))%>%separate(.,GTDB.Taxonomy,sep=";",into=c("domain","phylum","class","order","family","genus","species"))%>%filter(domain!="Archaea")


# pull out top 15 taxonomic groups

groups <- split_phylo %>% group_by(order) %>%
  summarise(count = n()) %>% arrange(desc(count))


groups$type <- "Other"
groups$type[1:15] <- groups$order[1:15]


#Read in the reference genome phylogeny and quality so we have access to that information if needed
ref_phylo<-read.csv("Data/ref_genomes.csv",sep="\t",header=TRUE)
ref.quality<-read_csv("Data/ref-quality-data.csv")

ref_phylo<-ref_phylo%>%mutate(user_genome=gsub(".[0-9]_.*[0-9a-zA-Z_]","",user_genome))

all.ref.info<-full_join(ref_phylo,ref.quality,by=join_by("user_genome"=="Genome"))
split.ref.info<-all.ref.info%>%mutate(classification=gsub("[a-z]__","",classification))%>%separate(.,classification,sep=";",into=c("domain","phylum","class","order","family","genus","species"))

split_ref_phylo<-ref_phylo%>%mutate(classification=gsub("[a-z]__","",classification))%>%separate(.,classification,sep=";",into=c("domain","phylum","class","order","family","genus","species"))

#Uncomment these lines if you want to add the reference genome orders to the tree
# ref_orders<-split_ref_phylo%>%filter(order!="")%>%reframe(unique(order))%>%as.matrix()%>%as.vector()
# ref_match<-match(ref_orders,groups$order)
# ref_match<-ref_match[is.na(ref_match)==FALSE]
# groups$type[ref_match]<-groups$order[ref_match]

split_phylo$group <- groups$type[match(split_phylo$order,groups$order)]

quality_data <- read.csv("Data/rxn_info.csv")

som_data <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(som_data)<-c("value","clusters")

# tree_wide <- as.tibble(tree)
# tree_wide$group <- split_phylo$group[match(tree_wide$label,split_phylo$prokka_id)]
# 
# tree_wide <- as.data.frame(tree_wide)

taxa_df <- data.frame(taxonomy = split_phylo$group[match(tree$tip.label, split_phylo$prokka_id)])
rownames(taxa_df) <- tree$tip.label
taxa_df$ref <- NA
taxa_df$ref[grep("GCF",rownames(taxa_df))] <- "Reference Genomes"
taxa_df$taxonomy[which(taxa_df$taxonomy == "Other")] <- NA
ref_df <- data.frame(ref = taxa_df[,-1])
taxa_df$ref <- NULL
rownames(ref_df) <- tree$tip.label


taxa_df$taxonomy <- factor(taxa_df$taxonomy)

labels <- data.frame(label = unique(taxa_df$taxonomy)) %>% arrange(label)

# convert back with as.phylo()
# t_plot <- ggtree(tree, aes(x,y,color=as.factor(support)), layout = "circular", lwd = 0.5, branch.length = "none")+scale_color_manual(values=c("orange","black")) + new_scale_color()
t_plot <- ggtree(tree, aes(x,y), layout = "circular", lwd = 0.05, branch.length = "none")

#Reorder the phylogeny colors to match downstream plots (currently doing this manually)
tree_colors<-phylo_colors[c(4,2,6,5,10,12,15,9,8,1,11,13,14,3,7)]

# t_plot <- rotate_tree(t_plot, 100)

out_tree <- gheatmap_hidden(t_plot, taxa_df, offset=-0.5, width=.05, colnames = FALSE) +
  scale_fill_manual(values = tree_colors, 
                     na.translate = FALSE) + 
  scale_color_manual(values =tree_colors, 
                    na.translate = FALSE) + labs(fill = "Taxonomy", color = "Taxonomy") + theme(legend.position="none")

# align text to taxonomy
tree_dat <- out_tree$data %>% filter(isTip == TRUE)

tax_labs <- data.frame(id = tree$tip.label)
tax_labs$labs <- split_phylo$group[match(tax_labs$id,split_phylo$prokka_id)]
tax_labs$pos <- tree_dat$y[match(tax_labs$id, tree_dat$label)]

tax_sum <- tax_labs %>% group_by(labs) %>%
  summarise(pos = mean(pos)) %>% filter(!is.na(labs), labs != "Other")

tax_sum$angles = (tax_sum$pos/max(tax_labs$pos)) * 360

tax_sum$hshift <- 1

tax_sum$nchar <- nchar(tax_sum$labs)
tax_sum$nchar[which(tax_sum$angles < 90 | tax_sum$angles > 270)] <- NA
tax_sum$hshift[which(tax_sum$angles > 90 & tax_sum$angles < 270)] <- 0 
tax_sum$angles[which(tax_sum$angles > 90 & tax_sum$angles < 270)] <- tax_sum$angles[which(tax_sum$angles > 90 & tax_sum$angles < 270)] + 180
tax_sum$labs <- factor(tax_sum$labs)

dist_max <- max(out_tree$data$x)

out_tree <- out_tree + geom_text(data = tax_sum, x = dist_max-5,
                     aes(y = pos, label = labs, angle = angles, hjust = hshift, color = labs),
                     vjust = 0.5, size = 4, fontface = "bold", show.legend = FALSE)

t_plot2 <- out_tree + new_scale_color() + new_scale_fill()

out_tree2 <- gheatmap2(t_plot2, ref_df, offset= 4, width=0.1, colnames = FALSE) +
  scale_fill_manual(values = c("red"), 
                    na.translate = FALSE) + 
  scale_color_manual(values = c("red"), 
                     na.translate = FALSE) + labs(fill = "", color = "") 

t_plot3 <- out_tree2 + new_scale_color() + new_scale_fill()

# quality data
quality_data$prokka_id <- paste0(quality_data$X,"-prokka")
qual_df <- data.frame(Quality = quality_data$mean_freq[match(tree$tip.label, quality_data$prokka_id)])
rownames(qual_df) <- tree$tip.label

out_tree3 <- gheatmap2(t_plot3, qual_df, offset= 14, width=0.1, colnames = FALSE) +
  scale_fill_gradient(low="gray99",high="black",na.value = "white", breaks = c(0,0.25,0.5,0.75,1)) + 
  scale_color_gradient(low="gray99",high="black",na.value = "white", breaks = c(0,0.25,0.5,0.75,1)) +
  # guides(color = guide_colorbar(title.hjust = 0.5, title.position = "top",
  #                               frame.colour = "black", ticks.colour = "black", barwidth = 10),
  #        fill = guide_colorbar(title.hjust = 0.5, title.position = "top",
  #                              frame.colour = "black", ticks.colour = "black",barwidth = 10)) +
  labs(fill = "Consensus", color = "Consensus") 

t_plot4 <- out_tree3 + new_scale_color() + new_scale_fill()

# now soms

som_data$prokka_id <- paste0(som_data$value,"-prokka")
som_df <- data.frame(som = som_data$clusters[match(tree$tip.label, som_data$prokka_id)])
rownames(som_df) <- tree$tip.label
som_df$som <- factor(som_df$som, levels = (1:num_clusters))

out_tree4 <- gheatmap2(t_plot4, som_df, offset= 24, width=0.1, colnames = FALSE) +
  scale_fill_manual(values = cluster_colors,na.translate = FALSE) + 
  scale_color_manual(values = cluster_colors, na.translate = FALSE) + labs(fill = "SOM Cluster", color = "SOM Cluster") +
  theme(legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.direction = "horizontal",
        legend.position = "bottom")


```

### Metabolite pattern analysis... done!

```{r Metabolite Classes, echo=FALSE}

#Single plot command to make violin plot of the total raw fluxes per cluster
raw_matrix<-as.data.frame(metabolite_matrix)%>%mutate(.,cluster=sample_clusters,total_limit=rowMeans(metabolite_matrix))

raw_df<-raw_matrix%>%group_by(cluster)%>%summarise(grow_mean=mean(total_limit))

raw.flux_plot<-ggplot(raw_matrix,aes(x=as.factor(cluster),y=total_limit))+
  geom_violin(width=1)+
  stat_summary(fun="mean",geom="crossbar",color="black")+
  labs(x="Clusters",y="Total Limitation")+
  geom_point(color="black")+
  theme_bw()+custom_theme

rowscaled_df<-as_tibble(metabolite_matrix)%>%mutate(.,clusters=sample_clusters,genomes=rownames(metabolite_matrix))%>%pivot_longer(-c(clusters,genomes),names_to="metab_class",values_to="scaled_flux")
rowscaled_df$clusters<-as_factor(rowscaled_df$clusters)

rowscaled.flux_plot<-ggplot(data=rowscaled_df,aes(x=scaled_flux,y=reorder(as.factor(clusters),desc(clusters)),fill=as.factor(clusters)))+geom_density_ridges(scale=0.9)+facet_wrap(~metab_class,scales="free_x")+theme(legend.position="none")+labs(x="Growth Sensitivity",y="Cluster")+custom_theme

plot(rowscaled.flux_plot)

all.piv.df<-rowscaled_df%>%group_by(clusters,metab_class)

all.piv.df <- all.piv.df %>% group_by(clusters) %>% mutate(min = min(scaled_flux),max = max(scaled_flux),polar_size = (scaled_flux)/(abs(max)+abs(min)))

all.piv.df$metabolite <- factor(all.piv.df$metab_class, levels = unique(all.piv.df$metab_class))

#Want to create plots of the SOM grids using the prototype values
#Create the prototypes dataframe, then modify it down to metabolite classes by averaging
classifiers_df <- as.data.frame(som.model$codes[[1]])

classifiers_df$nodes <- as.numeric(gsub("V","", rownames(classifiers_df)))
classifiers_df$cluster <- som.cluster.k
classifiers_df$column_names <- rep(c(1:gridsize,seq(0.5,gridsize-0.5, by = 1)), times = gridsize)[1:gridsize^2]
classifiers_df$row_names <- rep(seq(0.5,0.5*gridsize, by = 0.5), each = gridsize)

pivot_df <- classifiers_df %>% pivot_longer(-c(nodes,cluster,row_names,column_names), names_to = "metab_class", values_to = "scaled_flux")

pivot_df <- pivot_df %>% group_by(nodes) %>% mutate(min = min(scaled_flux),
                                                    max = max(scaled_flux),
                                                    polar_size = (scaled_flux)/(abs(max)+abs(min)))

pivot_df$metabolite <- factor(pivot_df$metab_class, levels = unique(pivot_df$metab_class))

#Manually adjust a couple of the long named metabolite classes for better plots
all.piv.df<-all.piv.df%>%mutate(metab_class=case_when(
  metab_class=="Phospholipids/Fatty Acids/Triglycerides" ~ "Phospholipids/Fatty\nAcids/Triglycerides",
  metab_class=="Nucleobases/Nucleosides/Nucleotides/Derivatives" ~ "Nucleobases/Nucleosides/\nNucleotides/Derivatives",
  .default=metab_class))

#Plot density ridges of the SOM prototypes per cluster
som.proto.dist_plot<-ggplot(data=all.piv.df,aes(x=scaled_flux,y=as.factor(clusters),fill=as.factor(clusters)))+
  geom_density_ridges(scale=0.9)+
  facet_wrap(~metab_class)+
  coord_cartesian(xlim=c(-0.05,1.05))+
  scale_fill_manual(values=cluster_colors)+
  scale_y_discrete(limits=rev)+
  scale_x_continuous(breaks=c(0,0.25,0.5,0.75,1),labels=c("0","0.25","0.5","0.75","1"))+
  theme(legend.position="none")+
  labs(x="Growth Sensitivity",y="Cluster")+
  custom_theme

plot_df = pivot_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = metab_class, y = scaled_flux, fill = metab_class) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1) +
                       coord_polar() +
                       scale_fill_manual(values = c("#ce4d3e",
                                                    "#66b045",
                                                    "#b256c2",
                                                    "#9a963f",
                                                    "#6569c8",
                                                    "#c88441",
                                                    "#5c9cd2",
                                                    "#d14788",
                                                    "#4fa67c",
                                                    "#bf82c1",
                                                    "#bb6271"))))

plot_df$column_names <- rep(c(1:gridsize,seq(0.5,gridsize-0.5, by = 1)), times = gridsize)[1:gridsize^2]
plot_df$row_names <- rep(seq(0.5,0.5*gridsize, by = 0.5), each = gridsize)

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.525, xmax = ..1+0.525,
                                               ymin = ..2-0.525, ymax = ..2+0.525))) %>%
  pull(annotation)


grid_plot <- ggplot() + 
  geom_point(data = classifiers_df, aes(x = column_names, y = row_names, color = as.factor(cluster)),
             fill = "white", size = 30, pch = 21, stroke = 4) +
  geom_col(data = pivot_df,
           aes(0,0, fill = metab_class)) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.key = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5)) + 
  labs(color="Cluster",fill = "Metabolite Class") + 
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5)) +
  scale_fill_manual(values = c("#ce4d3e",
                               "#66b045",
                               "#b256c2",
                               "#9a963f",
                               "#6569c8",
                               "#c88441",
                               "#5c9cd2",
                               "#d14788",
                               "#4fa67c",
                               "#bf82c1",
                               "#bb6271")) +
  scale_color_manual(values = c("#a0a052",
                                "#6c63d7",
                                "#a0b533",
                                "#c957ca",
                                "#5db855",
                                "#98459e",
                                "#d89d37",
                                "#7a93dd",
                                "#c9532a",
                                "#46aed7",
                                "#d6445a",
                                "#50b593",
                                "#d1438d",
                                "#4c7937",
                                "#c285de",
                                "#91682d",
                                "#625fa3",
                                "#dd8a68",
                                "#d883af",
                                "#a44d61"))+
  custom_theme

som_grid_plot<-ggplot() + 
  geom_point(data = classifiers_df, aes(x = column_names, y = row_names, fill=as.factor(cluster)), size = 18, pch = 21, stroke = 1)+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.key = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5)) + 
  labs(x="",y="",fill="Cluster") +
  scale_fill_manual(values = c("#4bafd0",
                               "#cb613f",
                               "#7277cb",
                               "#67b043",
                               "#b85ebc",
                               "#55a270",
                               "#c8577b",
                               "#ae9540"),
                    na.value="gray80")+
  custom_theme

#Further plots based on the metabolite classes for all som grid points

#Line to subset the data frame for only specific metabolite classes
classes<-c("Peptides","Amino Acids/Derivatives","B Vitamins","Nucleobases/Nucleosides/Nucleotides/Derivatives","Carboxylic Acid","Carbohydrates/Derivatives")
# pared_df<-all.metab.df%>%filter(metabolite_class%in%classes)

#Create data frame for looking at cluster mean and sd values for all of the original data rather than with the SOM prototype values
all.metab.df<-adjusted_dat%>%filter(metab_class=="Growth")%>%group_by(genome,model,X)%>%
mutate(growth_req=case_when(averaged_flux/orig_flux<=1 ~ (2*(1-averaged_flux/orig_flux)),averaged_flux/orig_flux>1 ~ 0))%>%
  reframe(growth_req=growth_req)
colnames(all.metab.df)<-c("genome","model","metabolite_class","growth_req")

all.metab.df<-left_join(all.metab.df,cluster_df,by=join_by(genome==value))

#Add plot that shows just the values

group.metab.df<-all.metab.df%>%group_by(clusters,metabolite_class)%>%summarise(means=mean(growth_req),sds=sd(growth_req))
group.metab.df$clusters<-as.factor(group.metab.df$clusters)

#Chunk of code to change names of metabolite classes to help with plotting
# group.metab.df<-group.metab.df%>%mutate(metabolite_class=case_when(
#   metabolite_class=="Nucleobases/Nucleosides/Nucleotides/Derivatives" ~ "Nucleobases/Nucleosides/\nNucleotides/Derivatives",
#   metabolite_class=="Phospholipids/Fatty Acids/Triglycerides" ~ "Phospholipids/Fatty\nAcids/Triglycerides",
#   .default=metabolite_class
# ))

metab_order <- group.metab.df %>% group_by(metabolite_class) %>%
  summarise(rank = mean(abs(means), na.rm = TRUE)) %>% arrange(desc(rank))

group.metab.df$metabolite_class <- factor(group.metab.df$metabolite_class,
                                     levels = metab_order$metabolite_class)

new_df <- group.metab.df %>% group_by(metabolite_class) %>%
  mutate(scaled_flux = ((means - min(means-sds))/(max(means+sds)-min(means-sds))))

new_df$metabolite_class <- factor(new_df$metabolite_class,
                                     levels = metab_order$metabolite_class)

#Plot bar plots using all of the original data
cluster_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = group.metab.df, aes(y = means, x = clusters, fill = clusters),
           stat = "identity") +
  geom_errorbar(data = group.metab.df, aes(x = clusters,ymin = means-sds, ymax = means+sds),
                width = 0.2) +
  scale_fill_manual(values=cluster_colors)+
  facet_wrap(vars(metabolite_class)) +
  labs(x = "", y= "Growth Sensitivity", fill = "Cluster") +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 18),
        axis.title = element_text(size =18),
        strip.text = element_text(size = 18),
        legend.text = element_text(size = 18),
        legend.title = element_text(size = 18),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position ="bottom",
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 1))


all.dat.clust.plot<-ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = group.metab.df, aes(y = means, x = clusters, fill = clusters),
           stat = "identity") +
  geom_errorbar(data = group.metab.df, aes(x = clusters,ymin = means-sds, ymax = means+sds),
                width = 0.2) +
  facet_wrap(vars(metabolite_class),scales="free_y") +
  labs(x = "", y= "Growth Limitation", fill = "Cluster") +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 16),
        axis.title = element_text(size =16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position ="bottom",
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 1))

sub_df<-new_df%>%filter(!metabolite_class%in%c("Alcohol","Amines/Amides","Ketones/Aldehydes","Organic Sulfur","Phospholipids/Fatty\nAcids/Triglycerides"))%>%mutate(metabolite_class=case_when(
  metabolite_class=="Nucleobases/Nucleosides/Nucleotides/Derivatives" ~ "Nucleobases/Nucleosides/\nNucleotides/Derivatives",
  metabolite_class=="Phospholipids/Fatty Acids/Triglycerides" ~ "Phospholipids/Fatty\nAcids/Triglycerides",
  .default=metabolite_class
))

flux_bubble_plot <- ggplot() +
  geom_vline(xintercept = factor(1:num_clusters), lty = 2, linewidth = 0.25) +
  geom_point(data = sub_df, aes(x = clusters, y = metabolite_class, fill = means, size = scaled_flux),pch=21) +
  scale_fill_gradientn(colours = c("darkorchid","gold"),
                       guide = "colorbar", limits=c(0,1), breaks = c(0,0.5,1),labels=c("0","0.5","1")) +
  scale_radius(range = c(10,30),limits = c(min(sub_df$means),1),breaks=c(min(sub_df$means),0.5,1),labels=c("0","0.5","1"),guide="legend") +
  labs(x = "Cluster", fill = "Growth Sensitivity", size = "Relative Sensitivity") +
  scale_y_discrete(limits=rev)+
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 20),
        axis.text.x = element_text(face="bold",size=20,color=c("#619CFF","#F8766D","#619CFF","#00BA38","yellowgreen","#00BA38","#619CFF","#619CFF")),
        axis.title.x = element_text(size = 20),
        legend.text = element_text(size  =20),
        legend.title = element_text(size  =20),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"),size=guide_legend(title.position="top",title.hjust=0.5))

#We also want to try to make a version where we only display the average relative flux values for each 
#Create a mean df from the classifiers df
all_means<-c()
for (i in 1:num_clusters){
  curr_means<-filter(classifiers_df,cluster==i)%>%select(!c(nodes,cluster,row_names,column_names))%>%colMeans(.)
  all_means<-rbind(all_means,curr_means)
}
mean_df<-as.data.frame(all_means,row.names = FALSE)

mean_df$nodes<-c(1:num_clusters)
mean_df$row_names<-c(1,2,3,4,1,2,3,4)
mean_df$column_names<-c(1,1,1,1,2,2,2,2)
mean_df$cluster<-c(1:num_clusters)

#Optional block of code for if you want to threshold

mean_df<-mean_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

pivot.mean_df<-mean_df %>% pivot_longer(-c(nodes, cluster, row_names, column_names),
                                          names_to = "metab_class", values_to = "scaled_flux") %>%
  group_by(nodes) %>% mutate(min = min(scaled_flux),
                             max = max(scaled_flux),
                             polar_size = (scaled_flux)/(abs(max)+abs(min)))

pivot.mean_df$metabolite <- factor(pivot.mean_df$metab_class, levels = unique(pivot.mean_df$metab_class))

plot_df = pivot.mean_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = metab_class, y = polar_size, fill = metab_class) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1) +
                       coord_polar() +
                       scale_fill_manual(values = c("#7663cf",
                                                    "#8db43b",
                                                    "#c851b1",
                                                    "#55bc63",
                                                    "#d54767",
                                                    "#4fbeae",
                                                    "#d15236",
                                                    "#588dcc",
                                                    "#d2a23a",
                                                    "#a879bf",
                                                    "#458149",
                                                    "#bd6484",
                                                    "#89883f",
                                                    "#ba7648"))))

plot_df$row_names <- c(1,2,3,4,1,2,3,4)
plot_df$column_names <- c(1,1,1,1,2,2,2,2)

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.5, xmax = ..1+0.5,
                                               ymin = ..2-0.5, ymax = ..2+0.5))) %>%
  pull(annotation)


flux_abund_plot <- ggplot() + 
  geom_point(data = mean_df[,1:4], aes(x = column_names, y = row_names,color=as.factor(cluster)),
             pch = 21, size = 50,stroke=2) +
  geom_col(data = pivot.mean_df,
           aes(0,0, fill = metab_class)) +
  coord_cartesian(expand = 10) +
  expand_limits(x=5,y=5) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5)) +
  scale_fill_manual(values = c("#7663cf",
                               "#8db43b",
                               "#c851b1",
                               "#55bc63",
                               "#d54767",
                               "#4fbeae",
                               "#d15236",
                               "#588dcc",
                               "#d2a23a",
                               "#a879bf",
                               "#458149",
                               "#bd6484",
                               "#89883f",
                               "#ba7648")) + labs(color="Cluster",fill = "Metabolite Class") + 
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5),color=guide_legend(title.position="top",override.aes=list(size=20)))

```

### Phylogenetic analysis... done!

```{r phylogeny, echo=FALSE}
#Code to examine the phylogeny of SOM clusters
#Load phylogeny and match it to genome IDs
phylo<-read.csv("Data/derep_all-GTDB-phylo_r214.tsv",sep="\t",header=TRUE)

split_phylo<-phylo%>%mutate(GTDB.Taxonomy=gsub("[a-z]__","",GTDB.Taxonomy))%>%separate(.,GTDB.Taxonomy,sep=";",into=c("domain","phylum","class","order","family","genus","species"))%>%filter(domain!="Archaea")

groups<-split_phylo%>%group_by(order)%>%summarise(count=n())%>%arrange(desc(count))

groups$type<-"Other"
groups$type[1:15]<-groups$order[1:15]
split_phylo$Genome.prokka<-gsub("-prokka","",split_phylo$Genome.prokka)
split_phylo$group<-groups$type[match(split_phylo$order,groups$order)]

#Code to compare the mean consensus values across taxonomic orders
new_phylo<-split_phylo
merge_data<-merge(new_phylo,quality_data,by.x="Genome.prokka",by.y="X",no.dups=TRUE)%>%select(c(prokka_id,order,mean_freq,group))

#Compute overall mean for each order
order_mean_freq<-merge_data%>%group_by(group)%>%summarise(mean=mean(mean_freq))%>%arrange(desc(mean))

#Compute percent of genomes in order above threshold
thresh<-0.8
order_hq_frac<-merge_data%>%group_by(group)%>%summarise(high.qual.frac=sum(mean_freq>thresh)/length(mean_freq))%>%arrange(desc(high.qual.frac))

#Isolate the correct subset of genomes and reduce the dataframe to match
split_phylo_hq<-split_phylo[split_phylo$Genome.prokka %in% genome_IDs,]%>%select(Genome.prokka,group)

#Regenerate a superClass object of the correct value K
clusters<-som.cluster.k
ids<-som.model$unit.classif
sample_clusters<-som.cluster.k[som.model$unit.classif]

#Use the majority clustering previously calculated to assign a cluster to each genome
match_rows<-match(split_phylo_hq$Genome.prokka,genome_IDs)
split_phylo_hq<-mutate(split_phylo_hq,cluster=majority_clust[match_rows])
phylo_mat<-matrix(data=0,nrow=num_clusters,ncol=16)
colnames(phylo_mat)<-unique(split_phylo_hq$group)
for (i in 1:num_clusters){
  curr_cluster<-split_phylo_hq%>%select(cluster,group)%>%filter(cluster==i)
  curr_phylo<-table(curr_cluster$group)
  phylo_cols<-match(names(curr_phylo),colnames(phylo_mat))
  phylo_mat[i,phylo_cols]<-curr_phylo
}
phylo_df<-as.data.frame(phylo_mat,row.names = FALSE)%>%mutate(.,cluster=c(1:num_clusters))%>%select(cluster,everything())

# ggplot(filter(phylo_df,cluster==1),aes(x="",y=value,fill=group))+
#   geom_col(color="black")+
#   geom_text(aes(x=1.35,label=value),position=position_stack(vjust=0.5))+
#   coord_polar(theta="y")+
#   theme_void()

#Now we want to plot all the pie charts together
phylo_df$nodes<-c(1:num_clusters)
phylo_df$row_names<-c(1,2,3,4,1,2,3,4)
phylo_df$column_names<-c(1,1,1,1,2,2,2,2)
phylo_df$cluster<-c(1:num_clusters)

#Optional block of code for if you want to threshold

phylo_df<-phylo_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

pivot_df<-phylo_df %>% pivot_longer(-c(nodes, cluster, row_names, column_names),
                                   names_to = "Group", values_to = "Number of Genomes") %>%
  group_by(nodes)

pivot_df$Order <- factor(pivot_df$Group, levels = unique(pivot_df$Group))

plot_df = pivot_df %>%
  nest(data=-nodes) %>%
  mutate(plot = map2(data, nodes,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = "", y = `Number of Genomes`, fill = Order)+
                       geom_col(color="black",show.legend=FALSE)+
                         coord_polar(theta="y")+
                       scale_fill_manual(values=c("#b8617c",
                                                  "#63b750",
                                                  "#895bc9",
                                                  "#b2b53b",
                                                  "#c84ca3",
                                                  "#3d854f",
                                                  "#d74164",
                                                  "#54bf9f",
                                                  "#cf5230",
                                                  "#54acd8",
                                                  "#d48e36",
                                                  "#5f7ac7",
                                                  "#6e772c",
                                                  "#bf83c9",
                                                  "#bca262",
                                                  "#b7694b"))))

pivot_df <- pivot_df %>% group_by(cluster) %>% mutate(perc = `Number of Genomes`/sum(`Number of Genomes`))

order_df <- pivot_df %>% group_by(Order) %>% summarise(mean = mean(perc)) %>%
  arrange(mean)

pivot_df$Order <- factor(pivot_df$Order, levels = order_df$Order)

phylo_abund_plot<-ggplot(pivot_df, aes(x = as.factor(cluster), y = perc, fill = Order)) +
  geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "Cluster", y = "Proportion")+
  custom_theme+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "gray"))+
  scale_y_continuous(breaks=c(0,0.2,0.4,0.6,0.8),labels=c("0","0.2","0.4","0.6","0.8"))+
  theme(legend.position="bottom",axis.text.x=element_text(size=20,face="bold",color=c("#619CFF","#F8766D","#619CFF","#00BA38","yellowgreen","#00BA38","#619CFF","#619CFF")),legend.text=element_text(size=20),axis.title.x=element_text(size=20),axis.title.y=element_text(size=20),axis.text.y=element_text(size=20),legend.title=element_text(size=20))

plot_df$row_names <- (c(1,2,3,4,1,2,3,4)-1)*2+0.55
plot_df$column_names <- (c(1,1,1,1,2,2,2,2)-1)*2+0.25
plot_df$cluster<-phylo_df$cluster
plot_df<-select(plot_df,nodes,cluster,row_names,column_names,everything())

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(column_names, row_names, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-0.9, xmax = ..1+0.9,
                                               ymin = ..2-0.9, ymax = ..2+0.9))) %>%
  pull(annotation)


phylo_grid_plot <- ggplot() +
  geom_col(data = pivot_df,
           aes(0,0, fill = Order))+
  geom_point(data = plot_df[,1:4], aes(x = column_names, y = row_names,color=as.factor(cluster)),
             pch = 21, size = 82.5,stroke=2)+
  coord_cartesian(expand = 10) +
  expand_limits(x=5,y=5) +
  plot_annotations + coord_equal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.box = "horizontal",
        plot.margin = ggplot2::margin(5,5,5,5))+ 
        labs(color="Cluster")+
  guides(fill = guide_legend(ncol = 2, title.position = "top", title.hjust = 0.5),color=guide_legend(title.position="top",override.aes=list(size=20)))+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "gray")) 

# print("Figure: ")
# plot(phylo_grid_plot)

#Try re-plotting this with one bar per phylogenetic order per cluster
phylo_stacked_abund_plot<-ggplot(pivot_df, aes(y = Order, x = perc, fill = as.factor(cluster))) +
  geom_bar(position="dodge",stat = "identity") + coord_cartesian(expand = FALSE) + labs(y = "Cluster", x = "Proportion", fill="Cluster")+
  scale_fill_manual(values = c("#a0a052","#6c63d7","#a0b533","#c957ca","#5db855","#98459e","#d89d37","#7a93dd","#c9532a","#46aed7","#d6445a","#50b593","#d1438d","#4c7937","#c285de","#91682d","#625fa3","#dd8a68","#d883af","#a44d61"))


#Now try re-plotting the same style chart but we want to compute a new metric -> relative abundance of orders in cluster compared to relative abundance of order in total dataset
#Get the whole data order abundances
fulldata_abundances<-table(split_phylo_hq$group)%>%as.data.frame()
colnames(fulldata_abundances)<-c("Order","Abundance")
fulldata_abundances<-mutate(fulldata_abundances,Abundance=Abundance/length(genome_IDs))

#Now we want to compute the ratio between the within cluster abundances and full data abundances
pivot_df$diff<-0
for (i in 1:length(fulldata_abundances$Order)){
  pivot_df<-pivot_df%>%mutate(diff=ifelse(Order==fulldata_abundances$Order[i],(perc/fulldata_abundances$Abundance[i])-1,diff))
}

#Now plot
phylo_rel_diff_plot<-ggplot(pivot_df, aes(y = as.factor(cluster), x = diff, fill = as.factor(cluster))) +
  geom_bar(width=0.65,position="dodge",stat = "identity")+
  expand_limits(x=c(min(pivot_df$diff-0.25),max(pivot_df$diff)+0.25)) +
  scale_y_discrete(limits=rev)+
  scale_fill_manual(values=cluster_colors)+
  geom_vline(xintercept=0,lty=2) + 
  scale_x_continuous(expand=expansion(mult=c(0,0.1))) + 
  labs(y = "Cluster", x = "Difference from Full Data (% change rel abundance)", fill="Cluster")+
  facet_wrap(~Order)+
  theme_bw()+
  custom_theme

#We want to look at the bray-curtis dissimilarity of the taxonomic distributions within each cluster
#We will look at the order level
bray_phylo<-split_phylo%>%select(c(Genome.prokka,order))%>%filter(Genome.prokka%in%genome_IDs)%>%mutate(group=gsub("o__","",order))

bray_phylo<-left_join(bray_phylo,cluster_df,by=join_by(Genome.prokka==value))

phylo_piv<-bray_phylo%>%group_by(group,clusters)%>%summarise(count=n())%>%group_by(clusters)%>%mutate(sum=sum(count))%>%group_by(clusters,group)%>%mutate(prop=count/sum)

phylo_piv<-phylo_piv%>%arrange(clusters)%>%select(-c(count,sum))%>%pivot_wider(names_from=clusters,values_from=prop,values_fill=0)%>%ungroup()
phylo_bray<-phylo_piv%>%select(-group)%>%as.matrix()%>%t()

bray <- vegdist(phylo_bray,method = "bray", upper = FALSE, diag = FALSE)
bray <- as.matrix(bray)
bray[lower.tri(bray,diag = TRUE)] <- NA
bray <- as.data.frame(bray)
bray$cluster1 <- rownames(bray)

# bray <- bray %>% pivot_longer(-cluster1, names_to = "cluster2", values_to = "bray") %>% filter(!is.na(bray))
# bray$K <- k
# bray_list[[k-1]] <- bray
# 
# 
# 
# bray_df <- do.call(rbind.data.frame, bray_list)
# bray_df$bray <- 1-bray_df$bray
# 
# bray_plot<-ggplot(bray_df, aes(x = as.factor(K), y = bray)) + geom_violin(width = 1) +
#   geom_jitter(width = 0.05) + labs(x = "K Value", y = "Bray-Curtis Similarity") +
#   theme_bw() + theme(text = element_text(size = 15))

```

### Growth estimate (dCUB) analysis... done!

```{r Growth Data, echo=FALSE, fig.width=12, fig.height=12}
#Plot a grid map with genomes as density, growth rates as a heatmap and colored borders by cluster

asinh_trans = function(){
  scales::trans_new("asinh",
                    transform = asinh,
                    inverse = sinh)

}

growth_dat<-read.csv("Data/growth_violin_data.csv")

#Plot the growth rate distributions for each cluster (ideally add in statistical sig as well)
growth_df<-cluster_df
growth_df<-mutate(growth_df,matchrow=match(cluster_df$value,growth_dat$Genome,nomatch=0))
replace_rows<-which(growth_df$matchrow>0)
growth_df<-growth_df%>%filter(.,matchrow>0)%>%mutate(dCUB=growth_dat$dCUB[matchrow])%>%select(-c(matchrow))
growth_df$clusters<-as.factor(growth_df$clusters)

#Preliminary non-parametric test of distributions with Kruskal-Wallis
kruskal.list<-list()
for (i in 1:num_clusters){
  kruskal.list[[i]]<-growth_df%>%filter(clusters==i)%>%select(dCUB)%>%as.matrix()
}
kruskal.out<-kruskal.test(kruskal.list)

print("Results of non-parametric Kruskal-Wallis Test:")
print(kruskal.out)

#Kruskal-Wallis is good with extremely strong p-value, suggesting differences in dCUB distributions, and our data is skewed normal so we will proceed with paired tests using Tukey's HSD
#Compute a tukey test on the samples grouped by cluster to see if any clusters are significantly different from one another
model=lm(growth_df$dCUB ~ growth_df$clusters)
ANOVA=aov(model)

TUKEY<-TukeyHSD(x=ANOVA,'growth_df$clusters',conf.level=0.95)
Tukey.levels<-TUKEY[["growth_df$clusters"]][,4]
growth.Tukey.labels<-data.frame(multcompLetters(Tukey.levels)['Letters'])
growth.Tukey.labels$treatment<-rownames(growth.Tukey.labels)
growth.Tukey.labels<-growth.Tukey.labels[order(growth.Tukey.labels$treatment),]
numeric.labels<-match(growth.Tukey.labels[,1],unique(growth.Tukey.labels[,1]))

growth_df<-growth_df%>%mutate(group=numeric.labels[clusters])

#We'd also like to do a comparison between the flux and growth rates by cluster to see if differentiation among slow clusters could be flux driven
avg_df<-group.metab.df%>%group_by(clusters)%>%summarise(flux_mean=mean(means))
avg_df<-avg_df%>%mutate(.,growth_mean=growth_df%>%group_by(clusters)%>%summarise(mean=mean(dCUB))%>%select(mean)%>%as.matrix()%>%as.numeric())
avg_df<-avg_df%>%mutate(tukey_groups=as.factor(numeric.labels))

growth_violin_plot<-ggplot(growth_df,aes(x=as.factor(clusters),y=dCUB,color=as.factor(group)))+
    geom_violin(width=1)+
    stat_summary(fun="mean",geom="crossbar",color="black")+
    labs(x="Clusters")+
    scale_color_manual(name="Group",values=c("#619CFF","#F8766D","#00BA38","yellowgreen"),labels=unique(growth.Tukey.labels[,1]))+
    geom_point()+
    custom_theme+
    theme_bw()

pivot.avg_df<-avg_df%>%pivot_longer(-c(clusters,tukey_groups))

flux_versus_growth_plot<-ggplot()+
  geom_point(data=pivot.avg_df,aes(x=clusters,y=value,color=tukey_groups,shape=name),size=4)+
  theme_bw()

#Different formulation of fuill data phylogeny plot where we show a ranked abundance curve of phylogeny broken out by cluster, colored by growth Tukey groups
per.clust.phylo.df<-pivot_df%>%mutate(tukey_group=growth.Tukey.labels$Letters[match(cluster,growth.Tukey.labels$treatment)])
per.clust.levels<-per.clust.phylo.df%>%filter(cluster==1)%>%arrange(desc(perc))%>%ungroup()%>%select(Group)%>%as.matrix()%>%as.vector()

per.clust.phylo.df<-per.clust.phylo.df%>%mutate(Group=factor(Group,levels=per.clust.levels))

per.clust.phylo_plot<-ggplot(per.clust.phylo.df,aes(x=Group,y=perc,fill=as.factor(tukey_group)))+geom_bar(position="dodge",stat="identity")+facet_wrap(~cluster,nrow=2)+theme_bw()+theme(axis.text.x=element_text(angle=45,hjust=1),legend.position="left")+labs(x="Taxonomic Order",y="Relative Abundance",fill="Statistical Group")

#Construct a dataframe of the per SOM grid point growth information
df <- carve.som %>% as.data.frame()
classifiers_df<-data.frame(nodes=rownames(df))%>%mutate(.,growth=0,`Number Genomes`=0)
classifiers_df$`Number Genomes`[names(gridpoint_table)%>%as.numeric()]<-gridpoint_table
for (i in 1:length(unique(gridpoint_df$gridpoints))){
  curr_point<-unique(gridpoint_df$gridpoints)[i]
  point_indices<-which(gridpoint_df$gridpoints %in% curr_point)
  point_matches<-match(gridpoint_df$value[point_indices],growth_dat$Genome,nomatch=0)
  point_matches<-which(point_matches>0)%>%point_matches[.]
  if (length(point_matches)>1){
    classifiers_df$growth[curr_point]<-mean(growth_dat$dCUB[point_matches])
  } else if (length(point_matches)==1) {
    classifiers_df$growth[curr_point]<-growth_dat$dCUB[point_matches]
  }
}

#Change any zero entries to NA
zero_loc<-which(classifiers_df$growth==0)
classifiers_df$growth[zero_loc]<-NA

classifiers_df$cluster <- clusters

classifiers_df$row_names <- rep(1:gridsize,times = gridsize)
classifiers_df$column_names <- rep(1:gridsize,each = gridsize)

classifiers_df<-classifiers_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

#Create a dataframe object that will draw the boxes around the cluster nodes
cluster_squares_df<-data.frame(cluster=c(1:num_clusters))
cluster_squares_df<-mutate(cluster_squares_df,xmin=0,xmax=0,ymin=0,ymax=0)
for (i in 1:num_clusters){
  curr_clust<-i
  curr_points<-filter(classifiers_df,cluster==i)%>%select(row_names,column_names)
  xmin=min(curr_points$column_names -0.4); xmax=max(curr_points$column_names +0.4); ymin=min(curr_points$row_names -0.4); ymax=max(curr_points$row_names +0.4)
  cluster_squares_df[i,c("xmin","xmax","ymin","ymax")]<-c(xmin,xmax,ymin,ymax)
}

# som_grid_plot<-ggplot() +
#   geom_rect(data=cluster_squares_df,mapping=aes(xmin=xmin, xmax = xmax, ymin = ymin, ymax= ymax,color=as.factor(cluster)),fill= "white", lwd = 2) +
#   geom_point(data= classifiers_df,aes(x = column_names, y = row_names, size = `Number Genomes`,fill=growth),pch=21,stroke=1) +
#   scale_fill_gradientn(colors = c("red","white","blue"), values = scales::rescale(c(-0.25,-0.09833212,-0.08)),
#                        guide = "colorbar", limits=c(-0.25,-0.08), 
#                        breaks = c(-0.25,-0.15,-0.08), labels = c("<-0.25","-0.15",">-0.08"),
#                        oob = scales::squish, trans = asinh_trans()) +
#   scale_size_continuous(range=c(4,14),breaks = c(0,150,300))+
#   theme(axis.title = element_blank(),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         panel.background = element_blank(),
#         legend.position = "bottom", legend.key = element_blank(),
#         legend.box = "vertical")+
#   guides(color=guide_legend(override.aes=list(size=5)))+
#   labs(size="Number of Genomes",fill="dCUB value",color="Cluster")+
#   coord_equal()

clust_df <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(clust_df)<-c("value","clusters")

clust_matches<-match(adjusted_dat$genome,clust_df$value)
adjusted_dat<-adjusted_dat%>%ungroup()%>%mutate(diff_flux=(averaged_flux-orig_flux),corrected_flux=correction*averaged_flux,corrected_diff_flux=(correction*(averaged_flux))-orig_flux,cluster=as.numeric(clust_df$clusters[clust_matches]))

#Construct 2d heatmaps of the fold changes in flux per treatment/metab class across clusters
grow.heat.dat<-adjusted_dat%>%select(c(X,genome,model,cluster,metab_class,corrected_flux,orig_flux))%>%mutate(fold_change=corrected_flux/orig_flux)%>%filter(!is.na(fold_change),fold_change!="Inf")

#Violin plots of everything
# ggplot(filter(grow.heat.dat,fold_change<5,!X==metab_class,X%in%c("Carbohydrates/Derivatives","Carboxylic Acid","Amino Acids/Derivatives","Peptides","B Vitamins"),!metab_class%in%c("Growth","Inorganic","Other")),aes(x=as.factor(X),y=fold_change))+geom_violin(aes(fill=as.factor(metab_class)),scale="width",draw_quantiles=c(0.5))+facet_wrap(~cluster,ncol=2)+labs(x="Removed Class",y="Fold Change Flux",fill="Response Class")+theme_bw()+custom_theme+theme(axis.text.x=element_text(angle=45,hjust=1,size=14),legend.position="bottom")

#Now incorporate mean sensitivity values
all.sensitivity<-adjusted_dat%>%filter(metab_class=="Growth")%>%group_by(genome,model,X)%>%
     mutate(growth_req=case_when(averaged_flux/orig_flux<=1 ~ (2*(1-averaged_flux/orig_flux)),averaged_flux/orig_flux>1 ~ 0))%>%
     reframe(growth_req=mean(growth_req))

grow.flux.dat<-left_join(grow.heat.dat,all.sensitivity,by=c("X","genome","model"))%>%filter(!X==metab_class,orig_flux>0.001,!metab_class%in%c("Growth","Inorganic","Other"))

group.flux.dat<-grow.flux.dat%>%group_by(X,cluster,metab_class)%>%summarise(median_change=median(fold_change),mean_req=mean(growth_req))

#Try just subsetting by fold change and plotting the raw distribution of values rather than summarizing
thresh.heat.dat<-left_join(grow.heat.dat,all.sensitivity,by=c("X","genome","model"))
thresh.perc.dat<-thresh.heat.dat%>%group_by(cluster,X,metab_class)%>%reframe(response_perc=sum(fold_change>3)/n(),sensitive_perc=sum(growth_req>=0.8)/n())

thresh.perc.dat<-thresh.perc.dat%>%mutate(cluster=case_when(cluster%in%c(1,3,7,8) ~ paste(cluster,"(Slow)"),cluster==2 ~ paste(cluster,"(Fast)"),cluster%in%c(4,6) ~ paste(cluster,"(Slow Intermediate)"),cluster==5 ~ paste(cluster,"(Fast Intermediate)")))

thresh.order<-thresh.perc.dat%>%group_by(X)%>%reframe(mean_perc=mean(sensitive_perc))%>%arrange(desc(mean_perc))
thresh.perc.dat$X<-factor(thresh.perc.dat$X,levels=thresh.order$X)

ggplot(thresh.perc.dat,aes(x=sensitive_perc,y=response_perc,color=as.factor(X)))+
  geom_point(size=3,alpha=0.7)+
  facet_wrap(~cluster,ncol=2)+
  scale_color_manual(values=c("#4aac8d","#d1418d","#66b24b","#815ecb","#d89f41","#688bcc","#d34f3f","#89923f","#c173c0","#ab6d3c","#bd6276"))+
  labs(x="Fraction of models with growth sensitivity >=0.8",y="Fraction of models with response flux fold changes >2",color="Removed/Sensitive Class")+
  theme_bw()+
  custom_theme+
  theme(legend.position="bottom",legend.text=element_text(size=12),legend.title=element_text(size=12))

#Compute pearson correlational analysis and plot correlations
correlation.plots<-ggplot(group.flux.dat,aes(x=mean_req,y=median_change))+
  geom_point()+
  geom_smooth(alpha=0.3,method="lm")+
  facet_wrap(~metab_class,scales="free_y")+
  labs(x="Mean Growth Sensitivity",y="Median Fold Change (All Classes)")+
  theme_bw()+
  custom_theme

#I want to filter out instances where the original flux was miniscule and use the median fold change rather than mean since there are some severe outliers in the data
group.heat.dat<-grow.heat.dat%>%filter(orig_flux>0.01,!metab_class%in%c("Growth","Inorganic","Other"))%>%group_by(X,metab_class,cluster)%>%summarise(median_change=median(fold_change))

#Also want to frame this data based on deviations from the full data values
all.median.dat<-grow.heat.dat%>%filter(orig_flux>0.01,!metab_class %in% c("Growth","Inorganic","Other"))%>%group_by(X,metab_class)%>%summarise(all.dat.median=median(fold_change))

group.heat.dat<-left_join(group.heat.dat,all.median.dat,by=c("X","metab_class"))%>%mutate(median_diff=median_change-all.dat.median)

#Now plot as geom_tiles faceted by cluster for both the raw cluster medians and the differential from full data
fc.heat.plot<-ggplot(group.heat.dat,aes(x=X,y=metab_class,fill=median_change))+
  geom_tile()+
  scale_fill_gradientn(colours = c("blue","white","red"),
                       values=scales::rescale(c(0,1,max(group.heat.dat$median_change))),breaks=c(0,0.5,1,2,3,4))+
  custom_theme+
  labs(x="Reduced Class",y="Measured Class",fill="Median Fold Change")+
  theme(axis.text.x=element_text(size=12,angle=45,hjust=1),axis.text.y=element_text(size=12),legend.text=element_text(size=12))+
  facet_wrap(~cluster,ncol=2)

plot(fc.heat.plot)

#I want to try stitching together sub-plots for each of the growth-based groups
slow_heat_plot<-ggplot(filter(group.heat.dat,cluster%in%c(1,3,7,8)),aes(x=X,y=metab_class,fill=median_diff))+
  geom_tile()+
  scale_fill_gradientn(colours = c("blue","white","red"),
                       values=scales::rescale(c(min(group.heat.dat$median_diff),0,max(group.heat.dat$median_diff))),limits=c(min(group.heat.dat$median_diff),max(group.heat.dat$median_diff)))+
  custom_theme+
  labs(x="Reduced Class",y="Measured Class",fill="",title="Slow growers")+
  theme(axis.text.x=element_text(size=12,angle=45,hjust=1),axis.text.y=element_text(size=12),axis.title.y=element_blank(),legend.position="none")+
  facet_wrap(~cluster,ncol=2)

inter_heat_plot<-ggplot(filter(group.heat.dat,cluster%in%c(4,5,6)),aes(x=X,y=metab_class,fill=median_diff))+
  geom_tile()+
  scale_fill_gradientn(colours = c("blue","white","red"),
                       values=scales::rescale(c(min(group.heat.dat$median_diff),0,max(group.heat.dat$median_diff))),limits=c(min(group.heat.dat$median_diff),max(group.heat.dat$median_diff)))+
  custom_theme+
  labs(x="Reduced Class",y="",title="Intermediate Growers",fill="Median Fold Change")+
  theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.title.x=element_blank(),axis.text.y=element_text(size=12),legend.position="bottom",legend.title=element_text(size=12,vjust=0.85),legend.text=element_text(size=12))+
  facet_wrap(~cluster,nrow=2)

fast_heat_plot<-ggplot(filter(group.heat.dat,cluster==2),aes(x=X,y=metab_class,fill=median_diff))+
  geom_tile()+
  scale_fill_gradientn(colours = c("blue","white","red"),
                       values=scales::rescale(c(min(group.heat.dat$median_diff),0,max(group.heat.dat$median_diff))),limits=c(min(group.heat.dat$median_diff),max(group.heat.dat$median_diff)))+
  custom_theme+
  labs(x="Reduced Class",y="Measured Class",fill="Median Fold Change",title="Fast grower")+
  theme(axis.text.x=element_text(size=12,angle=45,hjust=1),axis.text.y=element_text(size=12),legend.text=element_text(size=12),legend.position="none")+
  facet_wrap(~cluster,nrow=2)

slow_heat_plot+inter_heat_plot+fast_heat_plot

#Now try plotting difference betwween per-cluster and background data
all.fc.heat.plot<-ggplot(group.heat.dat,aes(x=X,y=metab_class,fill=median_diff))+
  geom_tile()+
  scale_fill_gradientn(colours = c("blue","white","red"),
                       values=scales::rescale(c(min(group.heat.dat$median_diff),0,max(group.heat.dat$median_diff))))+
  custom_theme+
  labs(x="Reduced Class",y="Measured Class",fill="Median Fold Change")+
  theme(axis.text.x=element_text(size=12,angle=45,hjust=1),axis.text.y=element_text(size=12),legend.text=element_text(size=12))+
  facet_wrap(~cluster,ncol=2)

#Format the growth data by cluster and removed metabolite class
grow_df<-adjusted_dat%>%filter(metab_class=="Growth")%>%group_by(genome,model,X)%>%
mutate(growth_req=case_when(averaged_flux/orig_flux<=1 ~ (2*(1-averaged_flux/orig_flux)),averaged_flux/orig_flux>1 ~ 0))%>%
  reframe(growth_req=growth_req)%>%select(-model)
colnames(grow_df)<-c("genome","metabolite_class","growth_req")

clust_matches<-match(grow_df$genome,clust_df$value)
grow_df<-grow_df%>%ungroup()%>%mutate(cluster=as.factor(as.numeric(clust_df$clusters[clust_matches])))


#Also plot the high sensitivity proportions for each metabolite class
high.sens.df<-grow_df%>%group_by(metabolite_class)%>%summarise(frac=sum(growth_req>=0.8)/n())
high.sens.df$metabolite_class=factor(high.sens.df$metabolite_class,levels=arrange(high.sens.df,desc(frac))$metabolite_class)
high.sens.plot<-ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = high.sens.df, aes(y = frac, x = metabolite_class, fill = metabolite_class),
           stat = "identity")+
  labs(x = "", y= "Proportion of Genomes", fill = "Metabolite Class") +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 16),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size =16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 16),
        title=element_text(size=16,hjust=0.5),
        legend.position="bottom",
        strip.background = element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25))+
  guides(fill=guide_legend(title.position="top",title.hjust=0.5,nrow=3))


all.deps_density<-ggplot(data=filter(grow_df,growth_req>=0),aes(x=growth_req,y=cluster,fill=cluster))+geom_density_ridges(stat="binline",scale=0.9)+facet_wrap(~metabolite_class)+theme_bw()+theme(legend.position="none")

sum_grow <- grow_df %>% group_by(cluster, metabolite_class) %>%
  summarise(avg_grow_req = mean(growth_req, na.rm = TRUE)) 

grow_order <- grow_df %>% group_by(metabolite_class) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

sum_grow$cluster <- factor(sum_grow$cluster)
sum_grow$metabolite_class <- factor(sum_grow$metabolite_class, levels = grow_order$metabolite_class)

out_grow <- ggplot(sum_grow, aes(y = metabolite_class, x = avg_grow_req, fill = cluster)) +
  geom_bar(stat= "identity", position = "dodge") + scale_x_continuous(expand = c(0,0), limits = c(0,1)) +
  labs(x = "Growth Sensitivity", y= "", fill = "SOM Cluster") + 
  theme(legend.position = c(0.97,0.97),
        legend.justification = c(1,1),
        legend.title = element_text(size = 12, angle = 90),
        legend.text = element_text(size =12),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 12),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        legend.background = element_rect(fill = "white", color = "black")) +
  guides(fill = guide_legend(title.position = "left", title.hjust = 0.5)) +
  geom_hline(yintercept = seq(1.5,11.5), lty = 2, lwd = 0.25) + ggtitle("A")

sum_grow <- sum_grow %>% group_by(metabolite_class) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req)))) 
  

growth_dep_plot <- ggplot(sum_grow, aes(x = cluster, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(guide = "none", range = c(2,10)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black")) +
  labs(x = "Cluster", fill = "Average Growth Sensitivity")

# compare plot
piv.mean_df <- mean_df%>% select(-c(nodes,row_names,column_names)) %>% pivot_longer(-cluster, names_to = "metabolite_class", values_to = "flux")
piv.mean_df$cluster <- factor(piv.mean_df$cluster)
comb_df <- full_join(sum_grow, piv.mean_df)

# plot regression lines
flux_versus_dep_plot<-ggplot(comb_df, aes(x = flux, y = avg_grow_req, color = cluster)) +
  geom_point(size = 4, alpha = 0.75) + facet_wrap(~metabolite_class, scales = "free_x") +
  labs(color = "Metabolite Class", x = "Growth Sensitivity", y = "Growth Sensitivity") +
  theme(panel.background = element_blank(), panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 10),
        legend.key = element_blank(),
        legend.position = "bottom",
        legend.direction = "horizontal") + 
  guides(color = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 1))

#Incomplete piece of code for plotting model growth rates against dCUB, need to recreate the hq.genomes_all.info data frame

# no.NAs_data<-hq.genomes_all.info_df%>%filter(dCUB!="NA")
# 
# groups<-no.NAs_data%>%group_by(Order)%>%summarise(count=n())%>%arrange(desc(count))
# 
# groups$type<-"Other"
# groups$type[1:15]<-groups$Order[1:15]
# groups$type<-gsub("o__","",groups$type)
# no.NAs_data$group<-groups$type[match(no.NAs_data$Order,groups$Order)]
# 
# ggplot()+
#   geom_point(data=no.NAs_data,aes(x=dCUB,y=`model growth`,group=as.factor(group),color=as.factor(cluster)))+
#   theme_bw()+
#   facet_wrap(~group)

#New version of bubble plot that tries to combine information from several plots. Want to try the metabolite dependence values as color and mean scaled fluxes as size
sum_grow$mean_flux<-new_df%>%ungroup%>%filter(metabolite_class%in%unique(sum_grow$metabolite_class))%>%select(means)%>%as.matrix()%>%as.numeric()
sum_grow$scaled_flux<-new_df%>%ungroup%>%filter(metabolite_class%in%unique(sum_grow$metabolite_class))%>%select(scaled_flux)%>%as.matrix()%>%as.numeric()

growth_dep_flux.size_plot <- ggplot(sum_grow, aes(x = cluster, y = metabolite_class, size = scaled_flux, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(range = c(0.01,10),limits=c(0,1)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"),size=guide_legend(title.position="top",title.hjust=0.5)) +
  labs(x = "Cluster", fill = "Average Growth Sensitivity",size="Relative Sensitivity")

#Also want to try plotting metabolite dependence in a few different arrangements, by total dependence and by growth (low to high)
#Match up the genomes from the grow_df to the phylo df
match_grow<-match(grow_df$genome,split_phylo_hq$Genome.prokka)
grow_df$group<-split_phylo_hq$group[match_grow]

#Plot the average growth sensitivity by top 15 orders
taxa.grow_df<-grow_df%>%group_by(group)%>%filter(group!="Other")%>%summarise(perc=sum(growth_req>=0.8)/n())%>%arrange(desc(perc))
taxa.grow_df$group<-factor(taxa.grow_df$group,levels=taxa.grow_df$group)

colors<-phylo_colors[match(levels(taxa.grow_df$group),levels(pivot_df$Order))]

phylo.high.sens.plot<-ggplot(taxa.grow_df,aes(x=group,y=perc,fill=group))+
  geom_bar(stat="identity")+
  geom_hline(yintercept=0,lty=2)+
  labs(x="",y="Proportion of Genomes")+
  scale_fill_manual(values=colors)+
  theme_bw()+
  custom_theme+
  theme(axis.text.x=element_text(hjust=1,angle=45),legend.position="none")

sum.taxa_df<-grow_df%>%group_by(metabolite_class,group)%>%summarise(avg_grow_req=mean(growth_req,na.rm=TRUE))

taxa.grow_order <- grow_df %>% group_by(group) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

sum.taxa_df$metabolite_class<-factor(sum.taxa_df$metabolite_class); sum.taxa_df$group<-factor(sum.taxa_df$group,levels=taxa.grow_order$group)

sum.taxa_df <- sum.taxa_df %>% group_by(group) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req)))) 

growth_dep_by.phylo_plot <- ggplot(sum.taxa_df, aes(x = group, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) + 
  geom_point(pch = 21) + scale_size_continuous(range = c(0.01,10),limits=c(0,1)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 10),
        axis.text.x=element_text(angle=45,hjust=1),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black"),size=guide_legend(title.position="top",title.hjust=0.5)) +
  labs(x = "Order", fill = "Average Growth Sensitivity",size="Relative Sensitivity")

#Additional plots looking at flux fold change in the growth data and also plotting the data in another way
adjusted_dat<-adjusted_dat%>%group_by(metab_class,X)%>%mutate(scaled_diff=case_when(max(abs(diff_flux))!=0 ~ diff_flux/max(abs(diff_flux)),max(abs(diff_flux))==0 ~ 0),scaled_corrected_diff=case_when(max(abs(corrected_diff_flux))!=0 ~ corrected_diff_flux/max(abs(corrected_diff_flux)),max(abs(corrected_diff_flux))==0 ~ 0))

#Create plot data
plot_dat<-adjusted_dat%>%filter(!metab_class%in%c("Other","Organic Sulfur","Amines/Amides","Alcohol","Inorganic"),!X%in%c("Other","Organic Sulfur","Amines/Amides","Alcohol"))%>%group_by(X,cluster,metab_class)%>%summarise(mean_diff=mean(diff_flux))

# plot_dat$X<-gsub("Amino_Acids","Amino Acids/Derivatives",gsub("B_vitamins","B Vitamins",gsub("Carbohydrates","Carbohydrates/Derivatives",gsub("Carboxylic_Acid","Carboxylic Acid",gsub("Nucleos","Nucleobases/Nucleosides/Nucleotides/Derivatives",plot_dat$X)))))

plot_dat<-plot_dat%>%filter(!X==metab_class)

plot_dat<-plot_dat%>%group_by(metab_class)%>%mutate(scaled_mean_diff=mean_diff/max(abs(mean_diff)))

# plot_dat$metab_class<-factor(plot_dat$metab_class,levels=c("Growth","Amino Acids/Derivatives","B Vitamins","Carbohydrates/Derivatives","Carboxylic Acid","Nucleobases/Nucleosides/Nucleotides/Derivatives","Peptides"))

#Version of the plot data where everything is corrected so the new media growth and original media growth are identical
growth.corrected.plot_dat<-adjusted_dat%>%filter(!metab_class%in%c("Other","Organic Sulfur","Amines/Amides","Alcohol","Inorganic"),!X%in%c("Other","Organic Sulfur","Amines/Amides","Alcohol"))%>%group_by(X,cluster,metab_class)%>%summarise(mean_diff=mean(corrected_diff_flux))%>%filter(!X==metab_class)

growth.corrected.plot_dat<-growth.corrected.plot_dat%>%group_by(metab_class)%>%mutate(scaled_mean_diff=mean_diff/max(abs(mean_diff)))

# growth.corrected.plot_dat$metab_class<-factor(growth.corrected.plot_dat$metab_class,levels=c("Growth","Amino Acids/Derivatives","B Vitamins","Carbohydrates/Derivatives","Carboxylic Acid","Nucleobases/Nucleosides/Nucleotides/Derivatives","Peptides"))

# ggplot(plot_dat,aes(x=metab_class,y=mean_diff,fill=X))+geom_bar(stat="identity",position=position_dodge())+facet_wrap(~cluster,nrow=2)+labs(x="Metabolite Class",y="Change in flux from original media to adjusted media",fill="Removed Class")+theme(axis.text.x=element_text(angle=45,hjust=1))+scale_fill_manual(values=c("#6a7fcf","#a69a3f","#ba5fb2","#59a967","#cc566a","#c96b39"))

#Alternative version where we plot all the removed classes together to plot everything in one figure
limitval=max(abs(min(growth.corrected.plot_dat$scaled_mean_diff)),max(growth.corrected.plot_dat$scaled_mean_diff))+0.5

plot_df <- as.data.frame(plot_dat) %>%
  nest(data=-cluster) %>%
  mutate(plot = map2(data, cluster,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = metab_class, y = scaled_mean_diff, fill = X) +
                       geom_bar(stat="identity", position = "dodge",show.legend = FALSE, alpha = 0.75, color = "black", width = 0.8) +
                       scale_y_continuous(limits = c(-limitval,limitval)) + 
                       coord_flip()+geom_hline(yintercept=0,lty=2,color="red")))

plot_annotations = plot_df %>%
  mutate(annotation = pmap(list(cluster, plot),
                           ~ annotation_custom(ggplotGrob(..2),
                                               xmin = ..1-0.65, xmax = ..1+0.65,
                                               ymin = 0.55, ymax = 9.45))) %>%
  pull(annotation)


all_plot <- ggplot() + 
  geom_point(data = growth.corrected.plot_dat, aes(x = cluster, y = metab_class), color = "white") + 
  plot_annotations + theme_classic()+
  theme(text = element_text(size = 15),
        axis.text.y=element_text(size=10),
        plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = 1:num_clusters, limits = c(0.5,num_clusters+0.5))+
  labs(x="Cluster",y="Change in flux from original to adjusted media")+custom_theme

legend_plot <- ggplot(growth.corrected.plot_dat, aes(x = 1, y = metab_class, fill = X)) +
  geom_tile(color = "white") + geom_tile(fill = "white",color = "white") +
  guides(fill=guide_legend(reverse = TRUE))+
  labs(fill = "Removed Class") +
  theme_void() + theme(text = element_text(size =15),
                       legend.position = c(0.5,0.5))

scale_dat<-growth.corrected.plot_dat%>%group_by(metab_class)%>%reframe(max=max(abs(mean_diff)))%>%mutate(class=c(1:length(metab_class)))

scale_plot<-ggplot(scale_dat,aes(x=max,y=class))+
  geom_point(size=3)+
  theme_bw()+
  theme(axis.ticks.y = element_blank(),axis.text.y = element_blank())+
  labs(x="Max scaling value",y="")

all_plot + legend_plot
# all_plot + scale_plot + legend_plot



adj_total_flux<-adjusted_dat%>%filter(!is.na(metab_class)&metab_class!="Growth")%>%group_by(genome,X,model)%>%summarise(total=sum(corrected_flux))%>%group_by(genome,X)%>%summarise(total=mean(total))
orig_total_flux<-original_dat%>%filter(!is.na(metab_class)&metab_class!="Growth")%>%group_by(genome,model)%>%summarise(total=sum(averaged_flux))%>%group_by(genome)%>%summarise(total=mean(total))
adj_total_flux$orig_total<-orig_total_flux$total[match(adj_total_flux$genome,orig_total_flux$genome)]

adj_total_flux<-adj_total_flux%>%mutate(diff=total/orig_total)
clust_matches<-match(adj_total_flux$genome,clust_df$value)
adj_total_flux<-adj_total_flux%>%ungroup()%>%mutate(cluster=clust_df$clusters[clust_matches])

#Plot the fold change in flux as a violin plot for each remove class and cluster (no statistical test on this data yet)
ggplot(data=adj_total_flux,aes(x=X,y=diff,fill=as.factor(cluster)))+geom_violin()+stat_summary(data=adj_total_flux,position=position_dodge(),fun="mean",geom="crossbar",color="black")+labs(x="Removed Class",y="Fold change in total flux from original to new media (corrected)",fill="Cluster")+theme(axis.text.x=element_text(angle=45,hjust=1))+custom_theme

flux_model=lm(adj_total_flux$diff ~ adj_total_flux$cluster)
ANOVA=aov(flux_model)

TUKEY<-TukeyHSD(x=ANOVA,'adj_total_flux$cluster',conf.level=0.95)
Tukey.levels<-TUKEY[["adj_total_flux$cluster"]][,4]
Tukey.labels<-data.frame(multcompLetters(Tukey.levels)['Letters'])
Tukey.labels$treatment<-rownames(Tukey.labels)
Tukey.labels<-Tukey.labels[order(Tukey.labels$treatment),]
numeric.labels<-match(Tukey.labels[,1],unique(Tukey.labels[,1]))

adj_total_flux$cluster<-as.numeric(adj_total_flux$cluster)
adj_total_flux<-adj_total_flux%>%mutate(group=numeric.labels[cluster],diff=case_when(diff>=50 ~ 50, diff<50 ~ diff))

ggplot(data=adj_total_flux,aes(x=as.factor(cluster),y=diff,fill=as.factor(group)))+geom_violin()+stat_summary(data=adj_total_flux,position=position_dodge(),fun="mean",geom="crossbar",color="black")+labs(x="Cluster",y="Fold change in total flux (growth corrected)",title="Distribution of average fold change in flux across all nutrient stress conditions")+scale_fill_discrete(name="Statistical Group",labels=unique(Tukey.labels[,1]))+theme(plot.title=element_text(hjust=0.5))+custom_theme


```

### Sub-clustering analysis... done!

```{r Sub-clustering, echo=FALSE}

#We want to specifically examine the phylogeny of sub-groups of grid points within individual SOM clusters.

sub.clust_phylo_df<-c()
for (curr_clust in 1:num_clusters){
  # curr_mean<-growth_df%>%filter(clusters==curr_clust)%>%ungroup()%>%select(dCUB)%>%as.matrix()%>%mean()
  # curr_mean<-mean(growth_df$dCUB)
  curr_mean=-0.08
  
  cluster_genomes<-growth_df%>%filter(clusters==curr_clust)%>%ungroup()%>%select(value,dCUB)
  
  #Split genomes based on growth
  high_growth_genomes<-cluster_genomes%>%filter(dCUB<curr_mean)%>%select(value)%>%as.matrix()
  low_growth_genomes<-cluster_genomes%>%filter(dCUB>=curr_mean)%>%select(value)%>%as.matrix()
  
  #Now find their phylogeny and plot it in terms of relative abundance
  high_growth_df<-cbind(high_growth_genomes,"high growth"); low_growth_df<-cbind(low_growth_genomes,"low growth")
  
  compare.grow_df<-as.data.frame(rbind(low_growth_df,high_growth_df)); colnames(compare.grow_df)<-c("Genome","Treatment")
  
  #Now add the relevant phylogeny to this dataframe
  phylo_mat<-matrix(data=0,nrow=2,ncol=16)
  colnames(phylo_mat)<-unique(split_phylo_hq$group)
  for (i in c("low growth","high growth")){
    if (i =="low growth"){
      genomes<-low_growth_genomes
      count<-1
    } else {
      genomes<-high_growth_genomes
      count<-2
    }
    curr_group<-split_phylo_hq%>%filter(., Genome.prokka%in%genomes)%>%select(group)%>%as.matrix()
    curr_phylo<-table(curr_group)
    phylo_cols<-match(names(curr_phylo),colnames(phylo_mat))
    phylo_mat[count,phylo_cols]<-curr_phylo
  }
  curr_df<-as.data.frame(phylo_mat,row.names = FALSE)%>%mutate(.,treatment=c("slow growth","fast growth"),cluster=curr_clust)%>%select(cluster,treatment,everything())
  
  sub.clust_phylo_df<-rbind(sub.clust_phylo_df,curr_df)
  
}



compare_df<-sub.clust_phylo_df %>% select(-c(Other)) %>% pivot_longer(-c(treatment,cluster),
                                                            names_to = "Group", values_to = "Number of Genomes") %>%
  group_by(treatment)

compare_df <- compare_df %>% group_by(cluster) %>% mutate(perc = `Number of Genomes`/sum(`Number of Genomes`))

#Now we want to compute the ratio between the within cluster abundances and full data abundances
compare_df$diff<-0
for (i in 1:length(fulldata_abundances$Order)){
  compare_df<-compare_df%>%mutate(diff=ifelse(Group==fulldata_abundances$Order[i],(perc/fulldata_abundances$Abundance[i])-1,diff))
}

#I need to make it so there is one set of taxonomic levels so the taxonomy colors are consistent
# order_df <- compare_df %>% group_by(Group) %>% summarise(mean = mean(perc)) %>%
#   arrange(mean)

compare_df$Group <- factor(compare_df$Group, levels = order_df$Order)
compare_df$cluster<-as.factor(compare_df$cluster)

#I'm also constructing two separate variables suitable to put the fraction of genomes in the low/high group as the plot title on facets
label_df<-compare_df%>%group_by(cluster,treatment)%>%summarise(total=sum(`Number of Genomes`))%>%group_by(cluster)%>%reframe(treatment=treatment,frac=total/sum(total))

slow_grow_labels<-paste("cluster",c(1:8),"proportion:",label_df%>%filter(treatment=="slow growth")%>%select(frac)%>%as.matrix()%>%round(.,digits=3)%>%as.character())
names(slow_grow_labels)<-levels(compare_df$cluster)

fast_grow_labels<-paste("cluster",c(1:8),"proportion:",label_df%>%filter(treatment=="fast growth")%>%select(frac)%>%as.matrix()%>%round(.,digits=3)%>%as.character())
names(fast_grow_labels)<-levels(compare_df$cluster)

#Plot facets for high versus low for all clusters
# ggplot(compare_df, aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "", y = "Proportion")+
#   facet_wrap(~cluster,nrow=4,ncol=2)+
#   theme(panel.spacing=unit(1,"lines"))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 


#Rather than above, let's do two distinct plots of all the high and low groups from each cluster separately
# cluster.slow_phylo_plot<-ggplot(filter(compare_df,treatment=="slow growth"), aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + 
#   facet_wrap(~cluster,nrow=4,labeller=labeller(cluster=slow_grow_labels))+
#   labs(title="Slow Growers",x = "", y = "Proportion")+
#   theme_bw()+
#   theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 
# 
# cluster.fast_phylo_plot<-ggplot(filter(compare_df,treatment=="fast growth"), aes(x = as.factor(treatment), y = perc, fill = Group)) +
#   geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + 
#   facet_wrap(~cluster,nrow=4,labeller=labeller(cluster=fast_grow_labels))+
#   labs(title="Fast Growers",x = "", y = "Proportion")+
#   theme_bw()+
#   theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
#   scale_fill_manual(values = c("#b8617c",
#                                "#63b750",
#                                "#895bc9",
#                                "#b2b53b",
#                                "#c84ca3",
#                                "#3d854f",
#                                "#d74164",
#                                "#54bf9f",
#                                "#cf5230",
#                                "#54acd8",
#                                "#d48e36",
#                                "#5f7ac7",
#                                "#6e772c",
#                                "#bf83c9",
#                                "#bca262",
#                                "#b7694b"),limits=force) 

#Plot the new version of the relative abundance charts
compare_df$cluster<-factor(compare_df$cluster,labels=paste("Cluster",c(1:num_clusters)))

cluster.phylo_plot<-ggplot(compare_df, aes(x = as.factor(treatment), y = perc, fill = Group)) +
  geom_bar(width=0.75,stat="identity") + coord_cartesian(expand = TRUE)+
  facet_wrap(~cluster,nrow=2)+
  labs(title="",x = "", y = "Proportion")+
  theme_bw()+
  custom_theme+
  theme(axis.text.x=element_text(size=18,angle=45,hjust=1),strip.text=element_text(size=18),legend.title=element_text(size=20),legend.text=element_text(size=18),axis.text.y=element_text(size=18),axis.title.y=element_text(size=18),legend.position="bottom")+
  theme(panel.spacing=unit(1,"lines"),plot.title=element_text(hjust=0.5))+
  guides(fill=guide_legend(ncol=4))+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b"),limits=force) 

#Now aggregate into just high and just low over all clusters and plot
mean.compare_df<-compare_df%>%select(-c(cluster))%>%group_by(treatment,Group)%>%summarise(mean_perc=mean(perc))

all.growth_phylo_plot<-ggplot(mean.compare_df,aes(x=as.factor(treatment),y=mean_perc,fill=Group))+geom_bar(stat = "identity") + coord_cartesian(expand = FALSE) + labs(x = "", y = "Proportion")+
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b"),limits=force) 
  

#I would also like to integrate the scaled fluxes from the SOMs with phylogeny to see if there are consistent patterns within the phylogenetic groupings either across the SOMs or within a SOM cluster
match_genomes<-match(split_phylo_hq$Genome.prokka,gridpoint_df$value)
flux_df<-split_phylo_hq%>%mutate(grid=gridpoint_df$gridpoints[match_genomes],cluster=cluster_df$clusters[match_genomes])

#Remake classifiers dataframe
df <- carve.som %>% as.data.frame()
classifiers_df<-data.frame(nodes=rownames(df))

classifiers_df$cluster <- clusters

classifiers_df$row_names <- rep(1:gridsize,times = gridsize)
classifiers_df$column_names <- rep(1:gridsize,each = gridsize)

classifiers_df<-cbind(classifiers_df,df)

classifiers_df<-classifiers_df%>%select(.,c(nodes,cluster,row_names,column_names),everything())

#Now compute a *weighed* mean using the gridpoints each taxa is in to get average scaled fluxes by taxa
phylo_flux<-c()
for (i in 1:length(unique(split_phylo_hq$group))){
  curr_group<-unique(split_phylo_hq$group)[i]
  filter_df<-flux_df%>%filter(.,group==curr_group)
  node_weights<-table(filter_df$grid); curr_nodes<-names(node_weights)%>%as.numeric()
  tmp_mat<-classifiers_df%>%filter(nodes%in%curr_nodes)%>%select(!c(cluster,nodes,row_names,column_names))%>%as.matrix()
  weighted_means<-colSums(node_weights*classifiers_df[curr_nodes,5:15])/sum(node_weights)
  
  phylo_flux<-rbind(phylo_flux,weighted_means)
}
new_flux_df<-as.data.frame(phylo_flux); colnames(new_flux_df)<-classifiers_df%>%select(-c(nodes,cluster,row_names,column_names))%>%colnames(.)
new_flux_df<-new_flux_df%>%mutate(taxa=unique(split_phylo_hq$group),nodes=c(1:length(unique(split_phylo_hq$group))))

new_flux_df$taxa<-factor(new_flux_df$taxa, levels = order_df$Order)

pivot_flux_df<-new_flux_df%>%pivot_longer(-c(taxa,nodes),names_to="Metabolite Class",values_to="Weighted Mean")

#Plot command to get bar charts, would like to add error lines. We will plot this two ways, grouped by metabolite class and grouped by taxa
#First we will group by metabolite class and facet wrap by taxa
metab.by.phylo_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = pivot_flux_df, aes(y = `Weighted Mean`, x = as.factor(`Metabolite Class`), fill = as.factor(`Metabolite Class`)),
           stat = "identity") +
  # geom_errorbar(data = group.metab.df, aes(x = cluster,ymin = means-sds, ymax = means+sds),
  #               width = 0.2) +
  facet_wrap(~`taxa`, ncol = 5, scales = "free_y") +
  labs(x = "", y= "Scaled Flux", fill = "Taxonomic Order") +
  scale_fill_manual(values = c("#7663cf",
                               "#8db43b",
                               "#c851b1",
                               "#55bc63",
                               "#d54767",
                               "#4fbeae",
                               "#d15236",
                               "#588dcc",
                               "#d2a23a",
                               "#a879bf",
                               "#458149",
                               "#bd6484",
                               "#89883f",
                               "#ba7648")) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size =12),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(0.95,0.05),
        legend.justification = c(1,0),
        axis.text.x=element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, ncol=3))

#Now plot with the taxa grouped and facet wrap by metabolite class
phylo.by.metab_plot <- ggplot() +
  geom_hline(yintercept = 0, lty = 2) +
  geom_bar(data = pivot_flux_df, aes(y = `Weighted Mean`, x = as.factor(nodes), fill = taxa),
           stat = "identity") +
  # geom_errorbar(data = group.metab.df, aes(x = cluster,ymin = means-sds, ymax = means+sds),
  #               width = 0.2) +
  facet_wrap(~`Metabolite Class`, ncol = 3, scales = "free_y") +
  labs(x = "", y= "Growth Sensitivity", fill = "Taxonomic Order") +
  scale_fill_manual(values = c("#b8617c",
                               "#63b750",
                               "#895bc9",
                               "#b2b53b",
                               "#c84ca3",
                               "#3d854f",
                               "#d74164",
                               "#54bf9f",
                               "#cf5230",
                               "#54acd8",
                               "#d48e36",
                               "#5f7ac7",
                               "#6e772c",
                               "#bf83c9",
                               "#bca262",
                               "#b7694b")) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size =12),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        strip.background = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(0.95,0.05),
        legend.justification = c(1,0),
        axis.text.x=element_blank(),
        panel.grid.major.y = element_line(color = "grey90", linewidth = 0.25)) +
  guides(fill = guide_legend(title.position = "top", title.hjust = 0.5, nrow = 4))

#Code to create growth plots of sub clusters
tmp_df<-growth_df%>%mutate(growth=case_when(dCUB < curr_mean ~ "fast", dCUB >= curr_mean ~ "slow", TRUE ~ "NA"))%>%filter(growth!="NA")

tmp_df$group<-factor(tmp_df$group,levels=c(1:4))

#Plot it
subcluster.growth_plot<-ggplot(tmp_df,aes(x=growth,y=dCUB,color=group))+
  facet_wrap(~clusters,nrow=2)+
  geom_violin(width=1)+
  stat_summary(fun="mean",geom="crossbar",color="black")+
  scale_color_discrete(name="Group",labels=unique(growth.Tukey.labels[,1]),drop=FALSE,limits=force)+
  labs(x="Group",color="Cluster")+
  geom_point()+
  ggtitle("Sub-grouped dCUB values for SOM clusters")+
  theme_bw()+
  theme(plot.title=element_text(hjust=0.5))


```

### Comparison to Matti's data... done!

```{r Matti Models, echo=FALSE}
# load("Data/all_carve-som-info_growth-data-hq.RData")
clusters<-clusters
ids<-som.model$unit.classif
sample_clusters<-som.cluster.k[som.model$unit.classif]

load(file="Data/matti-growth50-test-data_all-cats.Rdata")

matti.quality<-read_csv("Data/matti-quality-data.csv")

#Fix some string display issues with metabolite class names
remove_classes<-unique(all_dat$X)[-12]; metab_classes<-unique(all_dat$metab_class)[-c(7,8,12)]

match_rows<-match(all_dat$metab_class,metab_classes,nomatch=NA)

all_dat<-all_dat%>%mutate(X=case_when(X%in%remove_classes ~ metab_classes[match(X,remove_classes)],!X%in%remove_classes ~ X))

#Now we will separate out the original fluxes and add them to the dataframe so we can then compute differences
original_dat<-filter(all_dat,X=="original_media")
matti.adjusted_dat<-filter(all_dat,X!="original_media")

#For the version where we reduced the flux of metabolite classes to 0 there are some models with no growth so we should exclude those
nogrow_dat<-matti.adjusted_dat%>%filter(metab_class=="Growth"&averaged_flux<=10^-6)%>%reframe(ids=unique(paste(X,genome,model)))%>%as.matrix()
matti.adjusted_dat<-matti.adjusted_dat%>%mutate(key=paste(X,genome,model))%>%filter(!key%in%nogrow_dat)%>%select(-key)

#This line would be to average by all the models but we have information per model so not necessary (or reflective maybe). Requires adjusting the following lines too
# matti.adjusted_dat<-matti.adjusted_dat%>%group_by(X,metab_class,genome)%>%summarise(averaged_flux=mean(averaged_flux))%>%arrange(genome)

matti.adjusted_dat$orig_flux<-original_dat$averaged_flux[match(paste(matti.adjusted_dat$genome,matti.adjusted_dat$model,matti.adjusted_dat$metab_class),paste(original_dat$genome,original_dat$model,original_dat$metab_class))]

#There are some genomes with no metabolites from certain metabolite classes so let's now remove any rows with NA for the orig_flux
matti.adjusted_dat<-matti.adjusted_dat%>%filter(!is.na(orig_flux))

#We also want to make a growth corrected version of the data where we standardize the values by the differences in the original versus adjusted data
growth_correction<-matti.adjusted_dat%>%filter(metab_class=="Growth")%>%mutate(correction=orig_flux/averaged_flux)%>%select(X,genome,model,correction)
matti.adjusted_dat$correction<-growth_correction$correction[match(paste(matti.adjusted_dat$X,matti.adjusted_dat$model,matti.adjusted_dat$genome),paste(growth_correction$X,growth_correction$model,growth_correction$genome))]

matti.grow_df<-matti.adjusted_dat%>%filter(metab_class=="Growth")%>%group_by(genome,model,X)%>%
mutate(growth_req=case_when(averaged_flux/orig_flux<=1 ~ (2*(1-averaged_flux/orig_flux)),averaged_flux/orig_flux>1 ~ 0))%>%
  reframe(growth_req=mean(growth_req))
colnames(matti.grow_df)<-c("genome","model","metabolite_class","growth_req")

matti.grow_df<-matti.grow_df%>%pivot_wider(names_from=metabolite_class,values_from=growth_req)%>%mutate(genome=gsub("_matti","",genome))

matti.grow_df<-left_join(matti.grow_df,matti.quality,by=join_by("genome"=="Genome"))%>%filter(!is.na(Consensus),Consensus>=0.8)%>%select(-Consensus)

matti_matrix<-matti.grow_df%>%select(-c(genome,model))%>%as.matrix()
rownames(matti_matrix)<-matti.grow_df$genome%>%as.vector()

#Defunct piece of code to try and place Matti's genomes into the existing full data SOM, needs updating to kohonen and growth data to be functional
matti_headers<-read.csv("Data/matti_all_max_flux_headers_transposed.csv")
matti_dictionary<-read.csv("Data/matti_all_max_flux_met_names.csv")

matti_genomes<-unique(rownames(matti_matrix))
carve.som<-som.model$codes[[1]]
indices<-match(colnames(matti_matrix),colnames(carve.som))

match_fluxes<-carve.som[,indices]

averaged_fluxes<-c()
for (i in matti_genomes){
  curr_rows<-which(rownames(matti_matrix)==i)
  averaged_fluxes<-rbind(averaged_fluxes,colMeans(matti_matrix[curr_rows,]))
}

placed_points<-c()
placed_cluster<-c()
for (i in 1:dim(averaged_fluxes)[1]){
  curr_fluxes<-averaged_fluxes[i,]
  curr_dists<-dist(rbind(curr_fluxes,match_fluxes))[1:100]
  placed_point<-which(curr_dists==min(curr_dists))
  placed_points<-c(placed_points,placed_point)
  placed_cluster<-c(placed_cluster,clusters[placed_point])
}

sugar.acid.pref<-read_csv("Data/matti_sugar-acid-preference.csv")

# all_deps<-as.data.frame(metab_dependence$X)
# for (i in 1:num_clusters){
#   curr_clust<-paste("Cluster",i)
#   curr_genomes<-cluster_df%>%filter(clusters==i)%>%select(value)
#   match_genomes<-match(as.matrix(curr_genomes),colnames(metab_dependence))
#   curr_deps<-metab_dependence[,match_genomes]%>%rowMeans(.)
#   all_deps<-all_deps%>%mutate(!!curr_clust:=curr_deps)
# }
# all_deps<-as.data.frame(t(all_deps[,-1])); colnames(all_deps)<-metab_dependence$X

all_deps<-all.grow_df%>%pivot_longer(-c(genome,model),names_to="metab_class",values_to="grow_req")%>%group_by(genome,metab_class)%>%summarise(avg_grow_req=mean(grow_req))%>%pivot_wider(.,names_from=metab_class,values_from=avg_grow_req)

all_deps<-all_deps%>%mutate(cluster=cluster_df$clusters[match(genome,cluster_df$value)],`Carb/Acid Ratio`=(`Carbohydrates/Derivatives`/`Carboxylic Acid`)-1)%>%ungroup()%>%select(cluster,everything())

genome_df<-as.data.frame(unique(rownames(matti_matrix)))
colnames(genome_df)<-"Genome"
genome_df$cluster<-placed_cluster
match_genomes<-match(unique(matti_genomes),sugar.acid.pref$...1)
genome_loc<-which(is.na(match_genomes)==FALSE)
genome_df$preference<-NA ; genome_df$preference[genome_loc]<-sugar.acid.pref$`sugar-acid preference`[match_genomes[genome_loc]]

sugar.acid.pref_plot<-ggplot()+
  geom_violin(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=1)+
  geom_boxplot(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=0.25)+
  scale_y_continuous(sec.axis=sec_axis(trans=~.*1,name="Metabolite Preference"))+
  geom_jitter(data=filter(genome_df,preference!="NA"),aes(x=as.factor(cluster),y=as.numeric(preference)),width=0.05)+labs(x="Cluster",y="Sugar-Acid Preference")+
  geom_jitter(data=all_deps%>%ungroup()%>%select(-genome,cluster,`Carboxylic Acid`,`Carbohydrates/Derivatives`,`Carb/Acid Ratio`)%>%pivot_longer(-cluster),aes(x=as.factor(cluster),y=value,color=name),size=3,alpha=0.75,width=0.1)+
  scale_color_manual(values=c("#656cc5",
                              "#6ab64c",
                              "#a15acb",
                              "#c2a741",
                              "#cb4798",
                              "#4eb596",
                              "#d24150",
                              "#5e9bd4",
                              "#d3612b",
                              "#c483c5",
                              "#677e39",
                              "#ba5e73",
                              "#bd794d"))+
  labs(color="Metab Class Preference")+
  theme_bw()+ theme(text=element_text(size=15))+
  geom_hline(yintercept=0,linetype=2)

filter_df<-genome_df%>%filter(preference!="NA"); filter_df$preference<-as.numeric(filter_df$preference)

hq_genomes<-filter_df$Genome%>%as.matrix()
matti.grow_df<-matti.grow_df%>%filter(genome%in%hq_genomes)
# filter_df
# ggplot()+
#   geom_point(filter_df,aes())

cluster_medians<-filter_df%>%group_by(cluster)%>%summarise(median=median(preference))
#median_df<-cluster_medians%>%mutate(`Carboxylic Acid`=all_deps$`Carboxylic Acid`,`Carbohydrates`=all_deps$`Carbohydrates/Derivatives`)
median_df<-list(cluster_medians,select(all_deps,-genome))%>%reduce(full_join,by="cluster")%>%pivot_longer(-c(cluster,median),names_to="Metabolite Class",values_to="Metabolite Preference")
som_by_sugar.acid_plot<-ggplot()+
  geom_point(data=median_df,aes(x=median,y=`Metabolite Preference`,color=`Metabolite Class`))+
  labs(x="Median Sugar-Acid Preference",color="Cluster")+
  theme_bw()
  # +facet_wrap(~cluster,nrow=3,ncol=3)

#We also want to try to directly compare the predictions by CarveMe on matti's models to his experimentally validated growth rates on substrates
raw_growth_file<-read.csv("Data/Matti_growth-measurements.csv")
cols<-colnames(raw_growth_file)

#Manually slicing dataset for now but could use cols var + keywords
sugar_growth_info<-raw_growth_file[,c(11:38)]; colnames(sugar_growth_info)<-sugar_growth_info[1,]
sugar_growth_info<-sugar_growth_info[-1,]
acid_growth_info<-raw_growth_file[,c(39:81)]
colnames(acid_growth_info)<-acid_growth_info[1,]
acid_growth_info<-acid_growth_info[-1,]

#Compute the mean growth rate per genome on acids/sugars
sugar_means<-c()
for (i in 1:dim(sugar_growth_info)[1]){
  positive_growths<-which(sugar_growth_info[i,]>0)
  if (length(positive_growths)>1){
  curr_mean<-sugar_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()%>%mean()
  } else if (is_empty(positive_growths)==TRUE) {
    curr_mean<-0
  } else {
    curr_mean<-sugar_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()
  }
  sugar_means<-c(sugar_means,curr_mean)
}

acid_means<-c()
for (i in 1:dim(acid_growth_info)[1]){
  positive_growths<-which(acid_growth_info[i,]>0)
  if (length(positive_growths)>1){
  curr_mean<-acid_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()%>%mean()
  } else if (is_empty(positive_growths)==TRUE) {
    curr_mean<-0
  } else {
    curr_mean<-acid_growth_info[i,positive_growths]%>%as.vector()%>%as.numeric()
  }
  acid_means<-c(acid_means,curr_mean)
}
growth_means<-rowMeans(cbind(sugar_means,acid_means))

#Constructing a data frame with the genomes that were placed in SOMs and had non-NA sugar-acid preferences with their mean growth rates
mean.growth_df<-filter_df%>%filter(.,preference!="NA")%>%select(Genome)%>%mutate(`mean growth`=(match(Genome,raw_growth_file$X)-1)%>%growth_means[.])
mean.growth_df<-mean.growth_df%>%mutate(cluster=filter_df%>%filter(.,preference!="NA")%>%select(cluster)%>%as.matrix()%>%as.numeric())
colnames(mean.growth_df)[3]<-"cluster"

mean.growth_df<-mean.growth_df%>%group_by(.,cluster)%>%mutate(norm=`mean growth`/max(`mean growth`)*-1)
#Plot Matti's growth rates by cluster against the whole dataset growth rates by cluster
matti_growth_plot<-ggplot()+
  geom_violin(data=growth_df,aes(x=as.factor(clusters),y=dCUB),width=1)+
  stat_summary(data=growth_df,mapping=aes(x=as.factor(clusters),y=dCUB),fun="mean",geom="crossbar",color="blue")+
  geom_point(data=growth_df,aes(x=as.factor(clusters),y=dCUB))+
  geom_jitter(data=mean.growth_df,aes(x=as.factor(cluster),y=norm,color="red"),width=0.1,size=4,shape=18)+
  stat_summary(data=mean.growth_df,mapping=aes(x=as.factor(cluster),y=norm),fun="mean",geom="crossbar",color="red")+
  labs(color="Avg Growth",y="Cluster")+
  scale_colour_discrete(labels=c("Sugars+Acids"))+
  theme_bw()

#Pulling the names of the sugars then acids indivdiually to try to do per metabolite comparisons
data_sugars<-class_file%>%filter(.,Higher.Level.Classification=="Carbohydrates/Derivatives")%>%select(Metabolite)%>%as.matrix()
matti_sugars<-colnames(sugar_growth_info)

for (i in 1:length(matti_sugars)){
  matches<-grep(matti_sugars[i],data_sugars,ignore.case=TRUE)
  if (length(matches>2)){

  }
}


#We also want to look specifically at the metabolite dependences calculated on new CarveMe models run for Matti's genomes to match their experimental info to the CarveMe predicted info (mainly sugar/acid)
matti_dependencies<-matti.grow_df%>%mutate(genome=gsub("_matti","",genome))%>%pivot_longer(-c(genome,model),names_to="metab_class",values_to="grow_req")%>%group_by(genome,metab_class)%>%summarise(avg_grow_req=mean(grow_req))%>%pivot_wider(.,names_from="metab_class",values_from="avg_grow_req")%>%ungroup()

#Below code is in case the data is provided with the growth rates for each model as vectors in each index
# sub_df<-matti_dependencies%>%select(-c(som_cluster))
# for (i in 1:dim(sub_df)[1]){
#   for (j in 1:dim(sub_df)[2]){
#     sub_df[i,j]<-sub_df[i,j]%>%gsub('\\[|\\]','',.)%>%noquote()%>%strsplit(.,",")%>%unlist()%>%as.numeric()%>%mean()
#   }
# }

#Convert the growth rates into requirement values and reformat dataframe
# req_df<-sub_df
req_df<-matti_dependencies
# for (col in 1:dim(req_df)[2]){
#   req_df[,col]<-2*(1-(as.numeric(req_df[,col])/as.numeric(req_df[,1])))
# }

req_df<-req_df%>%select(genome,everything())
rownames(req_df)<-c()

#Add in the sugar/acid identifier to partition data
prefs<-sugar.acid.pref$`sugar-acid preference`[-1]%>%as.numeric()
binary_prefs<-vector(length=length(prefs))
binary_prefs[which(prefs>0)]<-"Sugar Preference"; binary_prefs[which(prefs<0)]<-"Acid Preference"

match_genomes<-match(raw_growth_file$X[-1],req_df$genome)
indices<-which(is.na(match_genomes)==FALSE)

req_df<-req_df%>%mutate(preference="Unmeasured",.before=`Carboxylic Acid`)
req_df$preference[match_genomes[indices]]<-binary_prefs[indices]

#Now plot the metabolite dependence values grouped by whether they are sugar or acid preferring oragnisms and their SOM cluster
matti.req_df<-req_df%>%select(-c(genome,preference))%>%t()%>%as.data.frame()%>%mutate(metabolite_class=rownames(.),.before=everything())
rownames(matti.req_df)<-NULL; colnames(matti.req_df)[-1]<-req_df$genome

matti.req_df <- matti.req_df %>% pivot_longer(-metabolite_class, names_to = "genome",values_to = "growth_req")
  # %>%filter(metabolite_class != "Inorganic")

# matti.req_df$cluster <- req_df$cluster[match(matti.req_df$genome,req_df$genome)]
matti.req_df$preference<-req_df$preference[match(matti.req_df$genome,req_df$genome)]

#Plot the density ridges for specific metabolite classes for all the dependence values of Matti's genomes
sub.matti.req_df<-matti.req_df%>%filter(metabolite_class%in%c("Amino Acids/Derivatives","Carbohydrates/Derivatives","Carboxylic Acid","Peptides"))

# matti.all.deps.density<-ggplot(data=sub.matti.req_df,aes(x=growth_req,y=preference,fill=preference))+geom_density_ridges(scale=0.9)+facet_wrap(~metabolite_class)+theme(legend.position="none")

matti.sum_grow <- matti.req_df %>% group_by(preference,metabolite_class) %>%
  summarise(avg_grow_req = mean(growth_req, na.rm = TRUE))

matti.grow_order <- matti.req_df %>% group_by(metabolite_class) %>%
  summarise(grow = mean(growth_req)) %>% arrange(desc(grow))

#matti.sum_grow$cluster <- factor(matti.sum_grow$cluster)
matti.sum_grow$preference<-factor(matti.sum_grow$preference)
matti.sum_grow$metabolite_class <- factor(matti.sum_grow$metabolite_class, levels = matti.grow_order$metabolite_class[c(4,1:3,5:12)])

matti.sum_grow <- matti.sum_grow %>% group_by(metabolite_class) %>%
  mutate(scaled_grow = ((avg_grow_req-min(avg_grow_req))/(max(avg_grow_req)-min(avg_grow_req))))

#Plot bar chart of just the amino acids/carbs by SAP group
# sub.grow<-matti.sum_grow%>%group_by(preference)%>%filter(metabolite_class%in%c("Carbohydrates/Derivatives","Amino Acids/Derivatives"),preference!="Unmeasured")
# 
# sub.grow_plot<-ggplot(sub.grow,aes(x=preference,y=avg_grow_req,fill=preference))+
#   geom_bar(stat="identity",position="dodge")+
#   facet_wrap(~metabolite_class,ncol=1)+
#   labs(x="",y="")+
#   theme_bw()+
#   custom_theme+
#   theme(legend.position="none")

sub.high.sens.grow<-matti.req_df%>%group_by(preference,metabolite_class)%>%summarise(perc=sum(growth_req>=0.8)/n())%>%arrange(desc(perc))%>%filter(metabolite_class%in%c("Carbohydrates/Derivatives","Amino Acids/Derivatives"))
sub.grow_plot<-ggplot(sub.high.sens.grow,aes(x=preference,y=perc,fill=preference))+
  geom_bar(stat="identity",position="dodge")+
  facet_wrap(~metabolite_class,ncol=1)+
  labs(x="",y="Proportion of genomes with substantial growth sensitivity")+
  theme_bw()+
  custom_theme+
  theme(legend.position="none")

matti_growth_dep_plot <- ggplot(matti.sum_grow, aes(x = preference, y = metabolite_class, size = scaled_grow, fill = avg_grow_req)) +
  geom_point(pch = 21) + scale_size_continuous(guide = "none", range = c(2,10)) +
  scale_fill_viridis_c() +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        legend.text = element_text(size  =12),
        legend.title = element_text(size  =12),
        legend.position = "bottom",
        legend.direction = "horizontal") +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(3.5, "in"),
                               ticks.colour = "black", frame.colour = "black")) +
  labs(x = "", fill = "Average Growth Sensitivity")

#Also want to plot the measured SAP (Sugar-Acid Preference) values from the experimental data against our version of SAP based on growth dependence
matti.SAP<-raw_growth_file[,c(1,9)]
colnames(matti.SAP)<-c("strain ID","Measured SAP")
matti.SAP<-matti.SAP[-1,]%>%as.data.frame()

matti.SAP<-left_join(matti.SAP,matti.quality,by=join_by("strain ID"=="Genome"))

#Filter only for the genomes that produced high quality models
hq.matti.SAP<-matti.SAP%>%filter(!is.na(Consensus),Consensus>=0.8)

#Select out the relevant categories from the growth dependence data frame and merge
sub.req.df<-req_df%>%select(c(genome,`Amino Acids/Derivatives`,`Carbohydrates/Derivatives`,`Carboxylic Acid`))

hq.matti.SAP<-left_join(hq.matti.SAP,sub.req.df,by=join_by("strain ID"=="genome"))%>%filter(!is.na(`Carboxylic Acid`))%>%select(-Consensus)

piv.hq.matti.SAP<-hq.matti.SAP%>%select(-c(`strain ID`))%>%pivot_longer(-c(`Measured SAP`),names_to="metab_class",values_to="growth_sensitivity")
piv.hq.matti.SAP$`Measured SAP`<-as.numeric(piv.hq.matti.SAP$`Measured SAP`)

#Now just try a simple plot of the SAP versus sensitivitiy for different classes
ggplot(piv.hq.matti.SAP,aes(x=`Measured SAP`,y=growth_sensitivity))+
  geom_point(size=3,alpha=0.5,color="blue")+
  facet_wrap(~metab_class)+
  labs(y="Growth Sensitivity")+
  theme_bw()+
  custom_theme

#Try also looking at the growth rate values compared to the metabolite dependence factors
#Identify which metabolites are present in our set of classified metabolites
match_acids<-c()
for (i in 1:length(colnames(acid_growth_info))){
  curr_search<-colnames(acid_growth_info)[i]
  matches<-grep(curr_search,class_file$Metabolite,ignore.case=TRUE)
  if (is_empty(matches)==TRUE){
    print(paste("Metabolite",curr_search,"has no matches!"))
    next
  }
  match_acids<-rbind(match_acids,as.matrix(class_file[matches,]))
}

match_sugars<-c()
for (i in 1:length(colnames(sugar_growth_info))){
  curr_search<-colnames(sugar_growth_info)[i]
  matches<-grep(curr_search,class_file$Metabolite,ignore.case=TRUE)
  if (is_empty(matches)==TRUE){
    print(paste("Metabolite",curr_search,"has no matches!"))
    next
  }
  match_sugars<-rbind(match_sugars,as.matrix(class_file[matches,]))
}


```

### Read recruitment analysis... done!

```{r Read Recruitment, echo=FALSE}
#Note to myself: there are only 3,917 genomes represented here which is the number of bacterial genomes in the dereplicated OMD, no archaea read recruitment, which makes sense
rpkm_vals <- read.csv("Data/carve_me_rpkm_1425.csv")
meta <- read.csv("Data/Estuary_metadata - Celeste_Paper.csv")

#I have discovered an issue in the metdata from Celeste's paper. The longitude values for the Pearl River estuary data is missing a one in the hundreds place (the longitude values are ~113 and reported as ~13). Implementing a manual fix
meta<-meta%>%mutate(lon=case_when(Region=="Pearl_river" ~ lon+100, Region!="Pearl_river" ~ lon))

som <- cbind(genome_IDs,majority_clust)%>%as.data.frame()
colnames(som)<-c("value","clusters")
som$value <- paste0(som$value,"-prokka-original")

colnames(rpkm_vals)[1] <- "Genome"

rpkm_vals <- rpkm_vals %>% pivot_longer(-Genome, names_to = "Sample", values_to = "rpkm")

per_samp_rpkm <- rpkm_vals %>% group_by(Sample) %>%
  summarise(sum_rpkm = sum(rpkm,na.rm = TRUE))

rpkm_vals$cluster <- som$clusters[match(rpkm_vals$Genome,som$value)]
rpkm_vals$Region <- meta$Region[match(rpkm_vals$Sample, meta$sra_acc)]

som_rpkm <- rpkm_vals %>% filter(!is.na(cluster),!is.na(rpkm)) %>% group_by(cluster, Sample) %>%
  summarise(sum_rpkm = sum(rpkm,na.rm = TRUE)) %>% ungroup() %>%
  group_by(Sample) %>%
  mutate(rel_rpkm = sum_rpkm/sum(sum_rpkm,na.rm=TRUE))

som_rpkm$cluster <- factor(som_rpkm$cluster)

som_rpkm$total_rpkm <- per_samp_rpkm$sum_rpkm[match(som_rpkm$Sample,per_samp_rpkm$Sample)]
som_rpkm$lat <- meta$lat[match(som_rpkm$Sample, meta$sra_acc)]
som_rpkm$long <- meta$lon[match(som_rpkm$Sample, meta$sra_acc)]
som_rpkm$Region <- meta$Region[match(som_rpkm$Sample, meta$sra_acc)]
som_rpkm$depth <- meta$depth[match(som_rpkm$Sample, meta$sra_acc)]

som_rpkm$lat[which(som_rpkm$lat == -3645)] <- (-36.45) # See if this is the issue

#There are some stations that do not have metadata like lat and long, might want to exclude these above, but definitely exclude below in the regional analysis
som_rpkm<-som_rpkm%>%filter(!is.na(Region))

#There is a Chesapeake Bay region and a CB region which also measures the Chesapeake Bay so I am going to merge these
# som_rpkm<-som_rpkm%>%mutate(Region=case_when(Region=="CB" ~ "Chesapeake Bay", Region!="CB" ~ Region))

#Want to try a couple of stacked abundance plots like in the Louca papers showing that phylogeny and function differ
#We want to try grouping the RPKM values into 5 major groups for an illustrative figure
rpkm_vals<-rpkm_vals%>%
  mutate(SuperRegion=case_when(
    Region %in% c("Chesapeake Bay","CB","Columbia River","Pearl_river","SFBay","Yaquina Bay") ~ "Estuarine",
    Region %in% c("NPAC","Sapelo","SI","GOM","Baltic Sea","Baltic_Pelagic","Black Sea") ~ "Coastal",
    Region %in% c("MED","RED") ~ "Oligotrophic Seas",
    Region %in% c("PON","POS","AON","AOS","ION","IOS","HOT") ~ "Oligotrophic Open Ocean",
    Region %in% c("SOC") ~ "Southern Ocean", .default=NA))

#Store the Sample -> Region -> SuperRegion info to easily join it to any dataframe
sample.classif<-rpkm_vals%>%select(Sample,Region,SuperRegion)%>%unique()%>%filter(!is.na(SuperRegion))

regional_rpkm<-som_rpkm%>%group_by(cluster,Region)%>%summarise(sum_rpkm=sum(sum_rpkm))%>%group_by(Region)%>%mutate(rel_rpkm=sum_rpkm/sum(sum_rpkm))

regional_rpkm<-regional_rpkm%>%mutate(SuperRegion=case_when(
    Region %in% c("Chesapeake Bay","CB","Columbia River","Pearl_river","SFBay","Yaquina Bay") ~ "Estuarine",
    Region %in% c("NPAC","Sapelo","SI","GOM","Baltic Sea","Baltic_Pelagic","Black Sea") ~ "Coastal",
    Region %in% c("MED","RED") ~ "Oligotrophic Seas",
    Region %in% c("PON","POS","AON","AOS","ION","IOS","HOT") ~ "Oligotrophic Open Ocean",
    Region %in% c("SOC") ~ "Southern Ocean", .default=NA))

regional_rpkm$SuperRegion<-factor(regional_rpkm$SuperRegion,levels=c("Estuarine","Coastal","Oligotrophic Seas","Oligotrophic Open Ocean","Southern Ocean"))
regional_rpkm$Region<-factor(regional_rpkm$Region,levels=unique(regional_rpkm$Region))
regional_rpkm<-regional_rpkm%>%arrange(SuperRegion)

ggplot(regional_rpkm,aes(x=Region,y=rel_rpkm,fill=cluster))+
  geom_bar(position="stack",stat="identity")+
  theme_bw()+
  theme(axis.text.x=element_text(size=12,angle=45,hjust=1))+
  scale_fill_manual(values=c("#cc5a43","#7764cb","#75ab3d","#c062bb","#54a77a","#c75980","#b68f40","#678ecd"))

#Now we want to look by individual sample
#Bootstrap the data by Sample
# set.seed(123)
# 
# sample.boot_df<-rpkm_vals%>%group_by(cluster,Sample)%>%reframe(Sample=unique(Sample))%>%filter(!is.na(cluster),!is.na(Sample))%>%mutate(boot_mean=NA,lb_boot=NA,ub_boot=NA)
# for (j in 1:length(unique(sample.boot_df$Sample))){
#   curr_region=unique(sample.boot_df$Sample)[j]
#   bootstrapped_sums<-matrix(data=NA,nrow=1000,ncol=num_clusters)
#   for (i in 1:num_clusters){
#     clust_rpkm<-rpkm_vals%>%filter(cluster==i,Sample==curr_region)%>%select(rpkm)%>%as.matrix()%>%as.numeric()
#     bootstrapped_sums[,i]<-generate_bootstrap_replicates(clust_rpkm,sum,n=1000,size=1000)
#   }
#   bootstrapped_rel_rpkm<-bootstrapped_sums/rowSums(bootstrapped_sums)
#   quantiles<-apply(bootstrapped_rel_rpkm,2,quantile,probs=c(2.5,97.5)/100)
#   means<-colMeans(bootstrapped_rel_rpkm)
#   sample.boot_df$lb_boot[which(sample.boot_df$Sample==curr_region)]<-quantiles[1,]
#   sample.boot_df$ub_boot[which(sample.boot_df$Sample==curr_region)]<-quantiles[2,]
#   sample.boot_df$boot_mean[which(sample.boot_df$Sample==curr_region)]<-means
# }
# sample.boot_df$Sample<-factor(sample.boot_df$Sample,levels=c("Estuarine","Coastal","Oligotrophic Seas","Oligotrophic Open Ocean","Southern Ocean"))


sample.som_rpkm<-som_rpkm%>%
  mutate(SuperRegion=case_when(
    Region %in% c("Chesapeake Bay","CB","Columbia River","Pearl_river","SFBay","Yaquina Bay") ~ "Estuarine",
    Region %in% c("NPAC","Sapelo","SI","GOM","Baltic Sea","Baltic_Pelagic","Black Sea") ~ "Coastal",
    Region %in% c("MED","RED") ~ "Oligotrophic Seas",
    Region %in% c("PON","POS","AON","AOS","ION","IOS","HOT") ~ "Oligotrophic Open Ocean",
    Region %in% c("SOC") ~ "Southern Ocean", .default=NA))

sample.som_rpkm$SuperRegion<-factor(sample.som_rpkm$SuperRegion,levels=c("Estuarine","Coastal","Oligotrophic Seas","Oligotrophic Open Ocean","Southern Ocean"))
sample.som_rpkm<-sample.som_rpkm%>%arrange(SuperRegion)
sample.som_rpkm$Sample<-factor(sample.som_rpkm$Sample,levels=unique(sample.som_rpkm$Sample))

ggplot(sample.som_rpkm,aes(x=Sample,y=rel_rpkm,fill=cluster))+
  geom_bar(position="stack",stat="identity")+
  scale_fill_manual(values=c("#cc5a43","#7764cb","#75ab3d","#c062bb","#54a77a","#c75980","#b68f40","#678ecd"))+
  theme_bw()

#Try clustering the stations within each regime and then reorder by regime and clustering order
all_order<-c()
for(i in c("Estuarine","Coastal","Oligotrophic Seas","Oligotrophic Open Ocean","Southern Ocean")){
  curr_df<-sample.som_rpkm%>%filter(SuperRegion==i)%>%select(cluster,Sample,rel_rpkm)%>%pivot_wider(names_from=cluster,values_from=rel_rpkm)
  curr_stations<-curr_df$Sample%>%as.vector()
  curr_mat<-curr_df[,-1]%>%as.matrix()
  curr_dist<-vegdist(curr_mat,method="euclidean")
  curr_clust<-hclust(curr_dist,method="mcquitty")
  
  curr_order<-curr_clust$order
  all_order<-c(all_order,curr_stations[curr_order])
}
#Now rearrange according to this order and plot
sample.som_rpkm$Sample<-factor(sample.som_rpkm$Sample,levels=all_order)

#Plot the three regions with lots of data as one group followed by the two small ones as another and stitch together with patchwerk
all.abund.plot1<-ggplot(filter(sample.som_rpkm,SuperRegion%in%c("Estuarine","Coastal")),aes(x=Sample,y=rel_rpkm,fill=cluster))+
    geom_bar(position="stack",stat="identity",width=1)+
    coord_cartesian(expand=FALSE)+
    scale_fill_manual(values=c("#cc5a43","#7764cb","#75ab3d","#c062bb","#54a77a","#c75980","#b68f40","#678ecd"))+
    theme_bw()+
  labs(x="",y="Relative RPKM values by sample")+
    facet_grid(cols=vars(SuperRegion),scales="free_x",space="free_x")+
    theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),panel.grid=element_blank(),legend.position="none")+
  custom_theme

all.abund.plot2<-ggplot(filter(sample.som_rpkm,SuperRegion%in%c("Oligotrophic Open Ocean")),aes(x=Sample,y=rel_rpkm,fill=cluster))+
    geom_bar(position="stack",stat="identity",width=1)+
    coord_cartesian(expand=FALSE)+
    scale_fill_manual(values=c("#cc5a43","#7764cb","#75ab3d","#c062bb","#54a77a","#c75980","#b68f40","#678ecd"))+
    theme_bw()+
    labs(y="")+
    facet_grid(cols=vars(SuperRegion),scales="free_x",space="free_x")+
    theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),panel.grid=element_blank(),legend.position="none",axis.text.y=element_blank(),axis.ticks.y=element_blank(),axis.title.y=element_blank())+
  custom_theme

all.abund.plot3<-ggplot(filter(sample.som_rpkm,SuperRegion%in%c("Oligotrophic Seas","Southern Ocean")),aes(x=Sample,y=rel_rpkm,fill=cluster))+
    geom_bar(position="stack",stat="identity",width=1)+
    coord_cartesian(expand=FALSE)+
    scale_fill_manual(values=c("#cc5a43","#7764cb","#75ab3d","#c062bb","#54a77a","#c75980","#b68f40","#678ecd"))+
    theme_bw()+
  labs(x="",fill="Cluster")+
    facet_grid(cols=vars(SuperRegion),scales="free_x")+
    theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),panel.grid=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(),axis.title.y=element_blank())+
  custom_theme

(all.abund.plot1 | all.abund.plot2 | all.abund.plot3) + plot_layout(widths=c(1,2,1),guides="collect")


#Bootstrap the data by Region to get bar plots
set.seed(123)

region.boot_df<-rpkm_vals%>%group_by(cluster,Region)%>%reframe(Region=unique(Region))%>%filter(!is.na(cluster),!is.na(Region))%>%mutate(boot_mean=NA,lb_boot=NA,ub_boot=NA)
for (j in 1:length(unique(region.boot_df$Region))){
  curr_region=unique(region.boot_df$Region)[j]
  bootstrapped_sums<-matrix(data=NA,nrow=1000,ncol=num_clusters)
  for (i in 1:num_clusters){
    clust_rpkm<-rpkm_vals%>%filter(cluster==i,Region==curr_region)%>%select(rpkm)%>%as.matrix()%>%as.numeric()
    bootstrapped_sums[,i]<-generate_bootstrap_replicates(clust_rpkm,sum,n=1000,size=10000)
  }
  bootstrapped_rel_rpkm<-bootstrapped_sums/rowSums(bootstrapped_sums)
  quantiles<-apply(bootstrapped_rel_rpkm,2,quantile,probs=c(2.5,97.5)/100)
  means<-colMeans(bootstrapped_rel_rpkm)
  region.boot_df$lb_boot[which(region.boot_df$Region==curr_region)]<-quantiles[1,]
  region.boot_df$ub_boot[which(region.boot_df$Region==curr_region)]<-quantiles[2,]
  region.boot_df$boot_mean[which(region.boot_df$Region==curr_region)]<-means
}
region.boot_df$Region<-factor(region.boot_df$Region,levels=c("Chesapeake Bay","CB","Columbia River","Pearl_river","SFBay","Yaquina Bay","NPAC","Sapelo","SI","GOM","Baltic Sea","Baltic_Pelagic","Black Sea","MED","RED","PON","POS","AON","AOS","ION","IOS","HOT","SOC"))

region.boot_df<-region.boot_df%>%mutate(growth=case_when(cluster==2 ~ "Fast Grower", cluster%in%c(4,6) ~ "Slow Intermediate",cluster==5 ~ "Fast Intermediate", .default="Slow Grower"))
region.boot_df$growth<-factor(region.boot_df$growth,levels=c("Fast Grower","Fast Intermediate","Slow Intermediate","Slow Grower"))

#Plot the bootstrapped output
regional.abund.plot<-ggplot(region.boot_df,aes(x=cluster,y=boot_mean,fill=growth))+
    geom_bar(stat="identity")+
    scale_fill_manual(values=c("#F8766D","yellowgreen","#00BA38","#619CFF"))+
    geom_hline(yintercept=0,lty=2)+
    geom_errorbar(aes(x=cluster,ymin=lb_boot,ymax=ub_boot),width=0.2)+
    facet_wrap(~Region)+
    custom_theme+
    labs(x="Cluster",y="Relative Bootstrapped RPKM",fill="Cluster")



#Bootstrap the data by SuperRegion to get bar plots
set.seed(123)

boot_df<-rpkm_vals%>%group_by(cluster,SuperRegion)%>%reframe(SuperRegion=unique(SuperRegion))%>%filter(!is.na(cluster),!is.na(SuperRegion))%>%mutate(boot_mean=NA,lb_boot=NA,ub_boot=NA)
for (j in 1:length(unique(boot_df$SuperRegion))){
  curr_region=unique(boot_df$SuperRegion)[j]
  bootstrapped_sums<-matrix(data=NA,nrow=1000,ncol=num_clusters)
  for (i in 1:num_clusters){
    clust_rpkm<-rpkm_vals%>%filter(cluster==i,SuperRegion==curr_region)%>%select(rpkm)%>%as.matrix()%>%as.numeric()
    bootstrapped_sums[,i]<-generate_bootstrap_replicates(clust_rpkm,sum,n=1000,size=10000)
  }
  bootstrapped_rel_rpkm<-bootstrapped_sums/rowSums(bootstrapped_sums)
  quantiles<-apply(bootstrapped_rel_rpkm,2,quantile,probs=c(2.5,97.5)/100)
  means<-colMeans(bootstrapped_rel_rpkm)
  boot_df$lb_boot[which(boot_df$SuperRegion==curr_region)]<-quantiles[1,]
  boot_df$ub_boot[which(boot_df$SuperRegion==curr_region)]<-quantiles[2,]
  boot_df$boot_mean[which(boot_df$SuperRegion==curr_region)]<-means
}
boot_df$SuperRegion<-factor(boot_df$SuperRegion,levels=c("Estuarine","Coastal","Oligotrophic Seas","Oligotrophic Open Ocean","Southern Ocean"))

#Add growth-based classifications for plots
boot_df<-boot_df%>%mutate(growth=case_when(cluster==2 ~ "Fast Grower", cluster%in%c(4,6) ~ "Slow Intermediate",cluster==5 ~ "Fast Intermediate", .default="Slow Grower"))
boot_df$growth<-factor(boot_df$growth,levels=c("Fast Grower","Fast Intermediate","Slow Intermediate","Slow Grower"))

#Plot the bootstrapped output
super.regional.abund.plot<-ggplot(boot_df,aes(x=cluster,y=boot_mean,fill=growth))+
    geom_bar(stat="identity")+
    scale_fill_manual(values=c("#F8766D","yellowgreen","#00BA38","#619CFF"))+
    geom_hline(yintercept=0,lty=2)+
    geom_errorbar(aes(x=cluster,ymin=lb_boot,ymax=ub_boot),width=0.2)+
    facet_wrap(~SuperRegion)+
    custom_theme+
    labs(x="Cluster",y="Relative Bootstrapped RPKM",fill="Cluster")


#There's something wrong with TARA_072_MES_0dot22_3 where it has an Inf rpkm value so I am going to arbitrarily remove it
som_rpkm<-som_rpkm%>%filter(!sum_rpkm=="Inf")
region.som.rpkm<-som_rpkm%>%group_by(cluster,Region)%>%summarise(sum_rpkm = sum(sum_rpkm,na.rm = TRUE),median_long=median(long),median_lat=median(lat)) %>% ungroup() %>%
  group_by(Region) %>%
  mutate(rel_rpkm = sum_rpkm/sum(sum_rpkm,na.rm=TRUE))

#Set up plots
plot_df = som_rpkm %>%
  nest(data=-Sample) %>%
  mutate(plot = map2(data, Sample,
                     ~ ggplot(.x) + theme_void() +
                       aes(x = "", y = rel_rpkm, fill = cluster) +
                       geom_bar(stat = "identity", show.legend = FALSE, width = 1, alpha = 0.7) +
                       coord_polar("y")))

plot_df$total_rpkm <- per_samp_rpkm$sum_rpkm[match(plot_df$Sample,per_samp_rpkm$Sample)]
plot_df$lat <- meta$lat[match(plot_df$Sample, meta$sra_acc)]
plot_df$long <- meta$lon[match(plot_df$Sample, meta$sra_acc)]
plot_df$Region <- meta$Region[match(plot_df$Sample, meta$sra_acc)]

plot_df$lat[which(plot_df$lat == -3645)] <- (-36.45) # See if this is the issue

plot_df <- plot_df %>% filter(!is.na(lat))

plot_annotations = plot_df %>% 
  mutate(annotation = pmap(list(long, lat, plot),
                           ~ annotation_custom(ggplotGrob(..3),
                                               xmin = ..1-5, xmax = ..1+5,
                                               ymin = ..2-5, ymax = ..2+5))) %>%
  pull(annotation)


map <- map_data("world")

all_recruitment_plot <- ggplot() + 
  geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
  plot_annotations +
  coord_cartesian(expand = 0) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
        axis.title = element_text(size = 15),
        axis.text = element_text(size = 15)) + 
  labs(x = "Longitude", y = "Latitude")

#We need to make some manual adjustments to certain lat/long values to get good separation for map plots
region.som.rpkm<-region.som.rpkm%>%mutate(
  median_lat=case_when(Region=="PON" ~ median_lat+15, Region=="Baltic Sea" ~ median_lat+5, .default = median_lat),
  median_long=case_when(Region=="Baltic Sea" ~ median_long+3.5, Region=="Baltic_Pelagic" ~ median_long+2, .default=median_long))

# regional.abund.plot<-ggplot(region.som.rpkm,aes(x=cluster,y=rel_rpkm,fill=cluster))+
#   geom_bar(stat="identity")+
#   geom_hline(yintercept=0,lty=2)+
#   facet_wrap(~Region)+
#   custom_theme+
#   labs(x="Cluster",y="Relative Total RPKM",fill="Cluster")

regional_map_plot<-ggplot() +
  geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
  geom_point(data = region.som.rpkm, aes(x = median_long, y = median_lat, size = sum_rpkm, color = rel_rpkm), alpha = 0.7) +
  coord_cartesian(expand = 0) + facet_wrap(~cluster) +
  scale_color_viridis_c(labels = scales::percent_format()) +
  scale_size_continuous(range = c(4,12), guide = "none") +
  labs(x = "Longitude", y = "Latitude", size = "Total RPKM", color = "Relative Abundance") +
  theme(plot.title=element_text(hjust=0.5),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 12),
        axis.text = element_text(size =12),
        axis.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.key = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(1,0),
        legend.justification = c(1,0)) +
  guides(color = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(2, "in")),
         size = guide_legend(title.position = "top", title.hjust = 0.5))

#Version of the plots to look at which dots in the regional map is representative of a given region (color by region)
# ggplot() +
#   geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
#   geom_point(data = filter(region.som.rpkm,cluster==1), aes(x = median_long, y = median_lat, size = sum_rpkm, color = Region), alpha = 0.7) +
#   coord_cartesian(expand = 0) + facet_wrap(~cluster) +
#   scale_size_continuous(range = c(15,15), guide = "none") +
#   labs(x = "Longitude", y = "Latitude", size = "Total RPKM", color = "Relative Abundance") +
#   scale_color_manual(values=c("#4d7c3a","#9c5bce","#5db746","#c74eaf","#a5b346","#5970d8","#d4a53e","#715ea1","#db863c","#5e99d4","#d04f27","#3dbbb8","#d53642","#5ab880","#d94e8c","#8e7a38","#c88bce","#a15430","#a14e6d","#e19385","#ce4161","#df6d61"))+
#   theme(plot.title=element_text(hjust=0.5),
#         panel.background = element_blank(),
#         panel.border = element_rect(fill = NA, color = "black"),
#         strip.background = element_blank(),
#         strip.text = element_text(size = 12),
#         axis.text = element_text(size =12),
#         axis.title = element_text(size = 12),
#         legend.text = element_text(size = 12),
#         legend.title = element_text(size = 12),
#         legend.key = element_blank(),
#         legend.direction = "horizontal",
#         legend.position = c(1,0),
#         legend.justification = c(1,0)) +
#   guides(size = guide_legend(title.position = "top", title.hjust = 0.5))


#Setting up more plots, grouped out by cluster
per_clust_map_plot<-ggplot() +
  geom_polygon(data = map, aes(x=long, y = lat, group = group), fill = "grey", color = "black") + 
  geom_point(data = som_rpkm, aes(x = long, y = lat, size = sum_rpkm, color = rel_rpkm), alpha = 0.7) +
  coord_cartesian(expand = 0) + facet_wrap(~cluster) +
  scale_color_viridis_c(labels = scales::percent_format()) +
  labs(x = "Longitude", y = "Latitude", size = "Total RPKM", color = "Relative Abundance") +
  theme(plot.title=element_text(hjust=0.5),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(size = 12),
        axis.text = element_text(size =12),
        axis.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.key = element_blank(),
        legend.direction = "horizontal",
        legend.position = c(1,0),
        legend.justification = c(1,0)) +
  guides(color = guide_colorbar(title.position = "top", title.hjust = 0.5, barwidth = unit(2, "in")),
         size = guide_legend(title.position = "top", title.hjust = 0.5))

```

###   Table Generation
```{r Creating Tables, echo=FALSE}
#We want to make some tables for the publication associated with this project
#Table defining metrics for each SOM cluster
main.text.table=data.frame(cluster=c(1:num_clusters),num_genomes=cluster_df%>%group_by(clusters)%>%summarise(count=n())%>%select(count)%>%as.matrix()%>%as.vector())%>%mutate(designation=c("Slow","Fast","Slow","Slow Intermediate","Fast Intermediate","Slow Intermediate","Slow","Slow"),limiting_substrates=c(
  c("Carboxylic Acids, Amino Acids"),
  c("None"),
  c("Carboxylic Acids, Peptides"),
  c("Amino Acids"),
  c("Carboxylic Acids"),
  c("Carbohydrates"),
  c("Peptides, Amino Acids"),
  c("Carboxylic Acids, Amino Acids, B vitamins")
),top2_taxa=c(
  c("Pelagibacterales, Marinisomatales"),
  c("Enterobacterales, Rhodobacterales"),
  c("Pelagibacterales, Cytophagales"),
  c("Flavobacterales, Synechococcales"),
  c("Pseudomonadales, Rhodobacterales"),
  c("Flavobacterales, Cytophagales"),
  c("Opituales, Pelagibacterales"),
  c("Flavobacterales, Pelagibacterales")
),top2_regions=c(
  c("Oligotrophic Seas, Oligotrophic Open Ocean"),
  c("Estuarine, Coastal"),
  c("Southern Ocean, Oliogtrophic Open Ocean"),
  c("Coastal, Estuarine"),
  c("Estuarine, Southern Ocean"),
  c("Southern Ocean, Coastal"),
  c("Estuarine, Oligotrophic Open Ocean"),
  c("Oligotrophic Seas, Oligotrophic Open Ocean")
))

#Table defining the SOM cluster assignment, dCUB, etc. of each genome
all.genome.table<-data.frame(genome=cluster_df$value,cluster=cluster_df$clusters)%>%left_join(.,select(growth_df,c(value,dCUB)),by=join_by(genome==value))%>%left_join(.,select(new_phylo,c(Genome.prokka,order,genus,species)),by=join_by(genome==Genome.prokka))
colnames(all.genome.table)<-c("Genome","Cluster","dCUB","Order","Genus","Species")

grow.req.per.genome<-grow_df%>%group_by(genome,metabolite_class)%>%summarise(mean_req=mean(growth_req))%>%pivot_wider(names_from=metabolite_class,values_from=mean_req)

all.genome.table<-left_join(all.genome.table,grow.req.per.genome,by=join_by(Genome==genome))

#Table for the read recruitment data by region that provides the RPKM values for each cluster, and the oceanographic regime
regional.RPKM.table<-region.boot_df%>%select(cluster,Region,boot_mean)%>%pivot_wider(names_from="cluster",values_from="boot_mean")
colnames(regional.RPKM.table)<-c("Region",paste("Cluster",c(1:num_clusters)))

superregion.rpkm.table<-boot_df%>%select(cluster,SuperRegion,boot_mean)%>%pivot_wider(names_from="cluster",values_from="boot_mean")
colnames(superregion.rpkm.table)<-c("Regime",paste("Cluster",c(1:num_clusters)))

#Save the p-values from the growth distribution comparisons
tukey_df<-TUKEY[["growth_df$clusters"]]%>%as.data.frame()
tukey_df<-tukey_df%>%mutate(names=rownames(tukey_df))

p.value.table<-tukey_df%>%select(names,"p adj")
colnames(p.value.table)<-c("Cluster Comparison","p value"); rownames(p.value.table)<-c()

```

## 3    Results

#### 3.1    Data phylogeny and model consensus

#### Figure 1: Phylogenetic Tree of Dataset. The first external ring shows the position of genomes belonging to the top 15 most abundant taxonomic orders. The second external ring shows the location of the reference genoms on which CarveMe was developed in red. The third external ring shows the consensus value for the CarveMe ensemble generated for each genome, while the final external ring shows the position of genomes belonging to each of the 8 SOM clusters for genomes that passed our consensus threshold.

```{r Tree plot, echo=FALSE, fig.width=12, fig.height=12}

plot(out_tree4)

```

### 3.2   CarveMe Validation

#### Supplemental Figure XX: Bubble plot of average growth dependency for genomes from xx Matti dataset xx grouped by their experimentally verified metabolic preference towards acids or sugars.

```{r Matti Growth Dependency Plot, echo=FALSE}

# plot(matti_growth_dep_plot)

```

<!-- #### Other Model validation Supplemental Figures: -->

<!-- ```{r Other Matti Data Plots, echo=FALSE} -->

<!-- plot(sugar.acid.pref_plot) -->

<!-- plot(som_by_sugar.acid_plot) -->

<!-- plot(matti_growth_plot) -->

<!-- ``` -->

### 3.3   SOM clustering

### 3.3.1   dCUB growth estimates

#### Figure 2: Violin plots of growth estimates (approximated by dCUB) for SOM clusters.

```{r Growth plot, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Distribution of dCUB values for each cluster with mean lines charted in black. Black squares represent the relative average growth sensitivity across clusters.")
plot(growth_violin_plot)

print("Figure: Average growth sensitivity and average dCUB value per cluster colored by statistically different groups by growth.")
plot(flux_versus_growth_plot)

print("Figure: Example of sub-clustering based on dCUB values")
plot(subcluster.growth_plot)

```

### 3.3.2 Metabolic profiles


#### Figure 3: Visualization of SOM map with individual grid point densities and xx color...

```{r SOM grid, echo=FALSE, fig.width=16, fig.height=16}

print("Figure: SOM grid grouped by cluster (squares), colored by dCUB, and sized based on number of genomes associated with each grid point.")
plot(som_grid_plot)

print("Distribution of total raw growth sensitivity values by cluster")
plot(raw.flux_plot)

print("Figure: Per grid point relative abundances of metabolite classes")
plot(grid_plot)

print("Figure: Raw growth sensitivity values per metabolite class grouped by cluster")
plot(all.dat.clust.plot)
  
print("Figure: Similar bubble plot to previous plot for growth sensitivity. Colors describe the information presented in above figure of the growth sensitivity values while bubble sizes describe the relative importance of each metabolite class between clusters.")
plot(flux_bubble_plot)


print("Figure: Per cluster relative abundances of metabolite classes.")
plot(flux_abund_plot)

print("Figure: Metabolite class enrichments grouped by taxonomic order")
plot(metab.by.phylo_plot)

print("Figure: Metabolite class enrichments for taxonomic orders grouped by metabolite class.")
plot(phylo.by.metab_plot)

```

### 3.3.3   Cluster phylogeny

```{r Phylogeny plots, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Within cluster relative abundances of top 15 phylogenetic orders (in total dataset) plus 'Other' category.")
plot(phylo_abund_plot)

print("Figure: Per cluster relative abundances of top 15 orders (in total dataset) grouped by order.")
plot(phylo_stacked_abund_plot)

print("Figure: Relative difference between within cluster and full dataset abundance of top 15 taxonomic orders grouped by order.")
plot(phylo_rel_diff_plot)

print("Figure: Relative abundances of top 15 orders for genomes in all fast and slow growth subclusters")
plot(all.growth_phylo_plot)

# print("Figure: Relative abundance of top 15 orders for each slow growing subcluster")
# plot(cluster.slow_phylo_plot)
# 
# print("Figure: Relative abundance of top 15 orders for each fast growing subcluster")
# plot(cluster.fast_phylo_plot)

print("Figure: Relative abundance of top 15 orders for the fast and slow growing subclusters")
plot(cluster.phylo_plot)

print("Figure: Bray-Curtis dissimilarity between the relative abundances of unique genuses in the dataset as cluster size is increased from 2 to 12 (NOTE: undefined genuses were defined as `order`_other).")
# print(bray_plot)


```

### 3.3.4   Growth Dependency/Requirement

```{r Metabolite Growth Dependence, echo=FALSE, fig.width=12, fig.height=12}

plot(growth_dep_plot)

```

#### Alternative Figure 4: Different plots of the same data. First alternative version shows same information, except bubble sizes are the average scaled fluxes of each metabolite class for each cluster. The second alternative version instead groups the dependence data by the top 15 taxonomic orders and sorts them from the order with the highest total dependence to the lowest total dependence.

```{r Alternative Figure 4, echo=FALSE}

plot(growth_dep_flux.size_plot)

plot(growth_dep_by.phylo_plot)

```


#### Supplemental Figure XX: Potential growth limitation grouped by metabolite class. Sets of bars for each metabolite class are colored by SOM cluster.

```{r Growth Limitation Chart, echo=FALSE}

plot(out_grow)

```

```{r Metabolite Dependence vs Scaled Flux, echo=FALSE}

print("Figure: Plot of scaled SOM prototype fluxes versus potential growth limitation by cluster for each of the metabolite classes.")
plot(flux_versus_dep_plot)

```

### 3.4   Geographic Distribution

```{r Read recruitment, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Read recruitment map showing the relative abundance of RPKM attributed to each cluster at each station.")
plot(all_recruitment_plot)

print("Figure: Per cluster read recruitment maps colored by relative contribution to total RPKM at each station. Bubble sizes reflect total RPKM value at each site.")
plot(per_clust_map_plot)

```

### Supplemental Figures

#### S1   SOM metrics

```{r SOM metrics, echo=FALSE, fig.width=12, fig.height=12}

print("Figure: Traditional PCA of data colored by SOM clusters")
plot(pca_plot)

print("Figure: Scaled mean flux values for metabolites with >10% flux relative to mean colored by cluter")
plot(mean_flux_clust_plot)

print("Figure: Scaled mean flux versus scaled mean standard deviation for metabolites with >10% flux relative to mean colored by cluster")
plot(mean_versus_std_flux_plot)

print("Figure: Distribution of coefficients of variance for each genome ensemble based on non-zero metabolite flux values for all ensemble models")
plot(coeffs_var_plot)

print("Figure: Distribution of counts of models in each cluster per genome.")
plot(evenness_plot)
# 
# print("Figure: Custom defined breadth, consensus, and evenness metrics for the distribution of each genome ensemble's models across clusters")
# plot(SOM_metrics_plot)

```

#### S2   Read recruitment

